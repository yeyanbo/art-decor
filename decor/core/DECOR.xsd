<!-- 
    
    DECOR schema
    Copyright (C) 2009-2014 Dr. Kai U. Heitmann
    
    This program is free software; you can redistribute it and/or modify it under the terms 
    of the GNU General Public License as published by the Free Software Foundation; 
    either version 3 of the License, or (at your option) any later version.
    
    This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    See the GNU General Public License for more details.
    
    See http://www.gnu.org/licenses/gpl.html
    
-->
<xs:schema xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://purl.oclc.org/dsdl/schematron" elementFormDefault="qualified">


    <!-- include DECOR datatype defintions -->
    <xs:include schemaLocation="DECOR-datatypes.xsd"/>

    <!-- this is the root element of any decor main file -->
    <xs:element name="decor">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Unique Ids</sch:title>
                    <sch:rule context="
                        project | 
                        project/author | 
                        datasets/dataset |
                        datasets/dataset//concept[not(ancestor::history)][not(parent::conceptList)] |
                        scenarios/actors/actor | 
                        scenarios/scenario | 
                        scenarios/scenario//transaction | 
                        terminology/valueSet[@id] | 
                        rules/template[@id] | 
                        issues/issue">
                        <sch:let name="currentId" value="@id"/>
                        <sch:let name="currentEffectiveDate" value="@effectiveDate"/>
                        <sch:let name="allCurrentIdEffectiveDates" value="
                            /decor/project[@id=$currentId] | 
                            /decor/project/author[@id=$currentId] | 
                            /decor/datasets/dataset[@id=$currentId and @effectiveDate=$currentEffectiveDate] |
                            /decor/datasets/dataset//concept[@id=$currentId and @effectiveDate=$currentEffectiveDate][not(ancestor::history)][not(parent::conceptList)] |
                            /decor/scenarios/actors/actor[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/scenarios/scenario[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/scenarios/scenario//transaction[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/terminology/valueSet[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/rules/template[@id=$currentId and @effectiveDate=$currentEffectiveDate] | 
                            /decor/issues/issue[@id=$currentId]"/>
                        <sch:let name="allCurrentIds" value="
                            /decor/project[@id=$currentId] | 
                            /decor/project/author[@id=$currentId] | 
                            /decor/datasets/dataset[@id=$currentId] | 
                            /decor/datasets/dataset//concept[@id=$currentId][not(ancestor::history)][not(parent::conceptList)] |
                            /decor/scenarios/actors/actor[@id=$currentId] | 
                            /decor/scenarios/scenario[@id=$currentId] | 
                            /decor/scenarios/scenario//transaction[@id=$currentId] | 
                            /decor/terminology/valueSet[@id=$currentId] | 
                            /decor/rules/template[@id=$currentId] | 
                            /decor/issues/issue[@id=$currentId]"/>
                        <sch:assert test="if (@effectiveDate) then (count($allCurrentIdEffectiveDates)=1) else (count($allCurrentIds)=1)">ERROR: The <sch:name/>/@id '<sch:value-of select="$currentId"/>' SHALL be unique.</sch:assert>
                    </sch:rule>
                </sch:pattern>
                <!-- transaction label is used for created of Schematron name. If there are duplicates, e.g. label="Acknowledgement", then this will cause Schematron generation to fail -->
                <sch:pattern>
                    <sch:title>Validate Unique Label</sch:title>
                    <sch:let name="allLabels" value="//scenario//transaction/@label"/>
                    <sch:rule context="scenario//transaction[@label]">
                        <sch:let name="scenarioStatus" value="ancestor::scenario/@statusCode"/>
                        <sch:let name="currentLabel" value="@label"/>
                        <sch:assert role="error" test="not($scenarioStatus='final') or count($allLabels[.=$currentLabel])=1">ERROR: <sch:name/>/@label '<sch:value-of select="$currentLabel"/>' within a
                                '<sch:value-of select="$scenarioStatus"/>' scenario MUST be unique in this Decor file</sch:assert>
                        <sch:assert role="warning" test="not($scenarioStatus='draft' or $scenarioStatus='new') or count(//scenario//transaction[@label=$currentLabel])=1">WARNING: <sch:name/>/@label
                                '<sch:value-of select="$currentLabel"/>' within a '<sch:value-of select="$scenarioStatus"/>' scenario SHOULD be unique in this Decor file</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="1" maxOccurs="1" ref="project">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Projectinformatie</xforms:label>
                            <xforms:label xml:lang="en-US">Project Information</xforms:label>
                            <xforms:label xml:lang="de-DE">Informationen zum Projekt</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Projectinformatie</xs:documentation>
                        <xs:documentation xml:lang="en-US">Project Information</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Informationen zum Projekt</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="1" ref="datasets">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Datasetdefinitie</xforms:label>
                            <xforms:label xml:lang="en-US">Data Set Definition</xforms:label>
                            <xforms:label xml:lang="de-DE">Data Set Definition</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Data Set Definitie</xs:documentation>
                        <xs:documentation xml:lang="en-US">Data Set Definition</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Data Set Definition</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element minOccurs="0" maxOccurs="1" ref="scenarios">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Scenariodefinitie</xforms:label>
                            <xforms:label xml:lang="en-US">Scenario Definition</xforms:label>
                            <xforms:label xml:lang="de-DE">Scenario Definition</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Scenariodefinitie, inclusief actoren, transacties, modellen, cardinaliteiten en conformancestatements</xs:documentation>
                        <xs:documentation xml:lang="en-US">Scenario Definition, with actors, transactions, models, cardinalities, conformance statements</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Scenario Definition, mit Aktoren, Transaktionen, Modellem, Kardinalitäten, Konformitätsangaben</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- identifiers -->
                <xs:element minOccurs="0" maxOccurs="1" ref="ids">
                    <xs:annotation>
                        <xs:appinfo>
                            <sch:pattern>
                                <sch:title>Validate Ids</sch:title>
                                <sch:let name="allTypes" value="tokenize('DS,DE,SC,TR,AC,VS,IS,RL,TM,CL,EL,SX,TX,EX,QX,CM,CS',',')"/>
                                <sch:let name="allTypesCount" value="count($allTypes)"/>
                                <sch:rule context="ids">
                                    <sch:let name="idsBaseIdTypes" value="count(distinct-values(baseId/@type))"/>
                                    <sch:let name="idsDefaultBaseIdTypes" value="count(distinct-values(defaultBaseId/@type))"/>
                                    <sch:let name="idsBaseIdTypesMissing" value="normalize-space(string-join(for $type in $allTypes return (if (not(baseId[@type=$type])) then (concat($type,' ')) else ('')),''))"/>
                                    <sch:let name="idsDefaultBaseIdTypesMissing" value="normalize-space(string-join(for $type in $allTypes return (if (not(defaultBaseId[@type=$type])) then (concat($type,' ')) else ('')),''))"/>
                                    <sch:assert role="warning" test="$idsBaseIdTypes&gt;=$allTypesCount">WARNING: you did not define a baseId for every possible type. This might lead to unexpected results. Expected '<sch:value-of select="$allTypesCount"/>', found '<sch:value-of select="$idsBaseIdTypes"/>'. Missing '<sch:value-of select="$idsBaseIdTypesMissing"/>'.</sch:assert>
                                    <sch:assert role="warning" test="$idsDefaultBaseIdTypes&gt;=$allTypesCount">WARNING: you did not define a defaultBaseId for every possible type. This might lead to unexpected results. Expected '<sch:value-of select="$allTypesCount"/>', found '<sch:value-of select="$idsDefaultBaseIdTypes"/>'. Missing '<sch:value-of select="$idsDefaultBaseIdTypesMissing"/>'.</sch:assert>
                                </sch:rule>
                            </sch:pattern>
                        </xs:appinfo>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Gebruikte identificaties</xforms:label>
                            <xforms:label xml:lang="en-US">Identifiers used</xforms:label>
                            <xforms:label xml:lang="de-DE">Genutzte Identifikatoren</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Gebruikte identificaties, bedoeld voor weergavedoeleinden</xs:documentation>
                        <xs:documentation xml:lang="en-US">Identifiers used, rendering only</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Genutzte Identifikatoren, nur zur Anzeige</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- terminology, e.g. value sets -->
                <xs:element minOccurs="0" maxOccurs="1" ref="terminology">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Terminologische definities</xforms:label>
                            <xforms:label xml:lang="en-US">Terminology definitions</xforms:label>
                            <xforms:label xml:lang="de-DE">Terminologische Definitionen</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Terminologische definities</xs:documentation>
                        <xs:documentation xml:lang="en-US">Terminology definitions</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Terminologische Definitionen</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- rules -->
                <xs:element minOccurs="0" maxOccurs="1" ref="rules">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Regeldefinities</xforms:label>
                            <xforms:label xml:lang="en-US">Rules definitions</xforms:label>
                            <xforms:label xml:lang="de-DE">Regeldefinitionen</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Regeldefinities</xs:documentation>
                        <xs:documentation xml:lang="en-US">Rules definitions</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Regeldefinitionen</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- issues -->
                <xs:element minOccurs="0" maxOccurs="1" ref="issues">
                    <xs:annotation>
                        <xs:appinfo>
                            <xforms:label xml:lang="nl-NL">Issuelijst</xforms:label>
                            <xforms:label xml:lang="en-US">Issue list</xforms:label>
                            <xforms:label xml:lang="de-DE">Problemliste</xforms:label>
                        </xs:appinfo>
                        <xs:documentation xml:lang="nl-NL">Issuelijst</xs:documentation>
                        <xs:documentation xml:lang="en-US">Issue list</xs:documentation>
                        <xs:documentation xml:lang="de-DE">Problemliste</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="repository" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project is een (building block) repository (BBR)</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project is a (building block) repository (BBR)</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt ist ein (Building Block) Repository (BBR)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Indication whether this DECOR project is a (building block) repository (BBR)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="private" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project is privé</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project is private</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt ist privat</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Indication whether this DECOR project is private, i.e. should NOT be included in searches from external.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="release" type="SmallNonNegativeInteger" fixed="1000" use="optional">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">DECOR-project release nummer</xforms:label>
                        <xforms:label xml:lang="en-US">DECOR project release number</xforms:label>
                        <xforms:label xml:lang="de-DE">DECOR-Projekt Release Nummer</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release number (dddd) of the DECOR project file, for conversion detection beteeen releases later</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <!-- 
    
        project
        
    -->
    <xs:element name="project">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="copyright" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="author" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="reference" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="restURI" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defaultElementNamespace" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="contact" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="buildingBlockRepository" minOccurs="0" maxOccurs="unbounded"/>
                <xs:choice maxOccurs="unbounded">
                    <xs:element name="version" type="ProjectHistory" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="release" type="ProjectRelease" minOccurs="0" maxOccurs="unbounded"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="prefix" type="ShortDescriptiveName" use="required"/>
            <xs:attribute name="defaultLanguage" type="xs:language" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="author">
        <xs:complexType mixed="true">
            <xs:attribute name="id" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">author's id, can be a shorthand id per project, e.g. "1"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="username" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">username, must be the same as the corresponding Exist-DB login name</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="email" type="EmailType" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">User's email address</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="notifier" type="NotifierOnOff" use="optional" default="on">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Specifies whether the automatic notifier system (if activated) should notify this author about changes of any project issue. Default is "on"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="copyright">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Copyright</sch:title>
                        <sch:rule context="copyright">
                            <sch:assert test="string-length(@years)&gt;0">ERROR: At least one year SHALL be present in copyright.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element ref="addrLine" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="years" type="YearRanges" use="required"/>
            <xs:attribute name="by" type="ShortDescriptiveName"/>
            <xs:attribute name="logo" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="addrLine">
        <xs:complexType mixed="true">
            <xs:sequence/>
            <xs:attribute name="type" type="AddressLineType" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="reference">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Reference</sch:title>
                        <sch:rule context="//project/reference">
                            <sch:assert test="substring(@url, string-length(@url), 1)='/'">ERROR: reference URL SHALL end with "/".</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="url" type="Uri"/>
            <xs:attribute name="logo" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="restURI">
        <xs:complexType mixed="true">
            <xs:attribute name="for" type="DecorObjectType" use="required"/>
            <xs:attribute name="format" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="defaultElementNamespace">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Standaard template-element namespace</xforms:label>
                <xforms:label xml:lang="en-US">Default Template Element Namespace</xforms:label>
                <xforms:label xml:lang="de-DE">Default Template Element Namespace</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">The default namespace prefix for all template element name definitions</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence/>
            <xs:attribute name="ns" type="NamespacePrefix" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="buildingBlockRepository">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate buildingBlockRepository</sch:title>
                    <sch:rule context="//project/buildingBlockRepository">
                        <sch:assert test="substring(@url, string-length(@url), 1)='/'">ERROR: repository URL SHALL end with "/".</sch:assert>
                        <sch:assert test="substring(@ident, string-length(@ident), 1)='-'">ERROR: repository ident SHALL end with "-".</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL">Repository referentie</xforms:label>
                <xforms:label xml:lang="en-US">Repository reference</xforms:label>
                <xforms:label xml:lang="de-DE">Repository Referenz</xforms:label>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">ART-DECOR repository reference</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence/>
            <xs:attribute name="url" type="Uri" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">ART-DECOR repository URI directly pointing to the services, e.g. "http://art-decor.org/services/"; ends with "/"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ident" type="NonEmptyString" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">ART-DECOR repository identification string (prefix), e.g. "ad1bbr-"; ends with "-"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="licenseKey" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">For future use</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    
    
    <!-- http://www.w3.org/TR/REC-xml/#NT-Name - didn't know how to code hex chars in pattern or I would have -->
    <xs:simpleType name="NamespacePrefix">
        <xs:restriction base="xs:string">
            <xs:pattern value="[^\s:\.0-9-][^\s:]*:"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="contact">
        <xs:complexType>
            <xs:attribute name="email" type="EmailType"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DecorObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Decor Object Types. Note: should you ever change list, please also see schematron check with name="Validate Ids".</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="DS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataset</xforms:label>
                        <xforms:label xml:lang="en-US">Data set</xforms:label>
                        <xforms:label xml:lang="de-DE">Datensatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">Dataset</xs:documentation>
                    <xs:documentation xml:lang="en-US">Data set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Datensatz</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Datenelement</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="nl-NL">data element</xs:documentation>
                    <xs:documentation xml:lang="en-US">data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Datenelement</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Scenario</xforms:label>
                        <xforms:label xml:lang="en-US">Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">scenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Szenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Transactie</xforms:label>
                        <xforms:label xml:lang="en-US">Transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">transactie</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">transaction</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="AC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actoren</xforms:label>
                        <xforms:label xml:lang="en-US">Actors</xforms:label>
                        <xforms:label xml:lang="d-DE">Akteure</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">actoren</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">actors</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Aktoren</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="VS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Waardelijst</xforms:label>
                        <xforms:label xml:lang="en-US">Value Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Value Set</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">waardelijst</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Value Set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="IS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Issue</xforms:label>
                        <xforms:label xml:lang="en-US">Issue</xforms:label>
                        <xforms:label xml:lang="de-DE">Problem/Frage</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">issue</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">issue</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Issue</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="RL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Regel</xforms:label>
                        <xforms:label xml:lang="en-US">Rule</xforms:label>
                        <xforms:label xml:lang="de-DE">Regel</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">regel (intern)</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">rule (internal)</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Regel (intern)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template</xforms:label>
                        <xforms:label xml:lang="en-US">Template</xforms:label>
                        <xforms:label xml:lang="de-DE">Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">template</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Conceptenlijst</xforms:label>
                        <xforms:label xml:lang="en-US">Concept list</xforms:label>
                        <xforms:label xml:lang="de-DE">Konzeptliste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">conceptenlijst</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">concept list</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Konzeptliste</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template-element</xforms:label>
                        <xforms:label xml:lang="en-US">Template Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">template-element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">template element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Template-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Testscenario</xforms:label>
                        <xforms:label xml:lang="en-US">Test Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Test-Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">testscenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">test scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Testszenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Test dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Test Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Test Data Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">test dataelement</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">test data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Testdaten-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Voorbeeldtransactie</xforms:label>
                        <xforms:label xml:lang="en-US">Example transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Beispiel-Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Example transaction</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Voorbeeldtransactie</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Beispiel-Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="QX">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Testeisen</xforms:label>
                        <xforms:label xml:lang="en-US">Test requirements</xforms:label>
                        <xforms:label xml:lang="de-DE">Test-Forderung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Test profile</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Test requirements</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Test-Forderung</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Community</xforms:label>
                        <xforms:label xml:lang="en-US">Community</xforms:label>
                        <xforms:label xml:lang="de-DE">Community</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Community. Expectation is that the DECOR-project assigns ids to communities under this base id, and communities branch under this base</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Community. Verwachting is dat het DECOR-project id's toekent aan communities en dat zij verder vertakken onder deze basis</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Community. Expectation is that the DECOR-project assigns ids to communities under this base id, and communities branch under this base</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Codesysteem</xforms:label>
                        <xforms:label xml:lang="en-US">Code system</xforms:label>
                        <xforms:label xml:lang="de-DE">Codesystem</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Code system</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Codesysteem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Codesystem</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--<xs:enumeration value="ID">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Identificatiekoppeling</xforms:label>
                        <xforms:label xml:lang="en-US">Identifier association</xforms:label>
                        <xforms:label xml:lang="de-DE">Identifier association</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Identifier association</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Identificatiekoppeling</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Identifier association</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TA">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Terminologiekoppeling</xforms:label>
                        <xforms:label xml:lang="en-US">Terminology association</xforms:label>
                        <xforms:label xml:lang="de-DE">Terminology association</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Identifier association</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Terminologiekoppeling</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Terminology association</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ProjectHistory">
        <xs:sequence>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="ShortDescriptiveName"/>
    </xs:complexType>
    <xs:complexType name="ProjectRelease">
        <xs:sequence>
            <xs:element name="note" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A human readable release note for convenient human rendition; not used by an application.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="ShortDescriptiveName"/>
        <xs:attribute name="versionLabel" type="ShortDescriptiveName">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A human readable version number or version label for convenient human rendition; not used by an application.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional"/>
    </xs:complexType>
    <xs:simpleType name="ReleaseStatusCodeLifeCycle">
        <!-- 
            release status codes
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">LifeCycle of the Status Code of a Release</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="draft">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontwerp</xforms:label>
                        <xforms:label xml:lang="en-US">Draft</xforms:label>
                        <xforms:label xml:lang="de-DE">Entwurf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release under development (nascent). Entered primarily to encourage other users to be aware of ongoing process.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="active">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actief</xforms:label>
                        <xforms:label xml:lang="en-US">Active</xforms:label>
                        <xforms:label xml:lang="de-DE">Aktiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release has been published by the governance group (custodian organization) and deemed fit for use. May have associated adoption and annotation metadata.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="pending">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Onder revisie vóór de publicatie</xforms:label>
                        <xforms:label xml:lang="en-US">Under pre-publication review</xforms:label>
                        <xforms:label xml:lang="de-DE">Unter Revision vor der Publikation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release is in pre-publication review: the Release is complete, pending appropriate review.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="retired">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Obsoleet</xforms:label>
                        <xforms:label xml:lang="en-US">Retired</xforms:label>
                        <xforms:label xml:lang="de-DE">Obsolet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release retired: No longer fit for use. Information available for historical reference.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Release was never published as active and is withdrawn.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="datasets">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="dataset" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="dataset">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Data Concept</sch:title>
                    <sch:rule context="dataset//concept[not(ancestor-or-self::history|parent::conceptList)]">
                        <sch:let name="did" value="(ancestor-or-self::dataset/@id)[last()]"/>
                        <sch:let name="cid" value="@id"/>
                        <sch:let name="cef" value="@effectiveDate"/>
                        <sch:assert test="count(//dataset[@id = $did]//concept[not(ancestor-or-self::history|parent::conceptList) and @id = $cid and @effectiveDate = $cef])=1">ERROR: A concept within
                            a dataset SHALL be unique with respect to its @id and @effectiveTime (id: <sch:value-of select="$cid"/>)</sch:assert>
                        <sch:report role="warning" test="count(//dataset[@id = $did]//concept[not(ancestor-or-self::history|parent::conceptList) and @id = $cid])&gt;1">WARNING: A concept within a
                            dataset SHOULD be unique with respect to its @id (id: <sch:value-of select="$cid"/>)</sch:report>
                        <!--<sch:report role="warning" test="1=1">XXXXX: (<sch:value-of select="$did"/>)(<sch:value-of select="$cid"/>)</sch:report>-->
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="concept" type="DataSetConcept" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="DataSetConceptValue">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element name="property" type="DataSetValueProperty" minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="conceptList" type="DataSetConceptList" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:appinfo>
                        <sch:pattern>
                            <sch:title>Validate Data Concept List</sch:title>
                            <sch:rule context="dataset//valueDomain/conceptList[not(ancestor::history)]">
                                <sch:let name="cid" value="@id"/>
                                <sch:let name="cref" value="@ref"/>
                                <sch:assert role="error" test="not(@id) or count(ancestor::datasets//valueDomain/conceptList[@id=$cid][not(ancestor::history)])=1">ERROR: The concept list id '<sch:value-of select="$cid"/>' SHALL be unique within the project</sch:assert>
                                <sch:assert role="error" test="not(@ref) or ancestor::datasets//valueDomain/conceptList[@id=$cref][not(ancestor::history)]">ERROR: The concept list ref '<sch:value-of select="$cref"/>' SHALL have a corresponding conceptList element in the same project</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                </xs:annotation>
                <xs:unique name="conceptlistuniquekey">
                    <xs:selector xpath=".//concept"/>
                    <xs:field xpath="@id"/>
                </xs:unique>
            </xs:element>
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
        </xs:choice>
        <xs:attribute name="type" type="DataSetValueType" use="required"/>
    </xs:complexType>
    <xs:complexType name="DataSetValueProperty">
        <xs:attribute name="unit" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Eenheid</xforms:label>
                    <xforms:label xml:lang="en-US">Unit</xforms:label>
                    <xforms:label xml:lang="de-DE">Einheit</xforms:label>
                </xs:appinfo>
                <xs:documentation>unit for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="currency" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Valuta</xforms:label>
                    <xforms:label xml:lang="en-US">Currency</xforms:label>
                    <xforms:label xml:lang="de-DE">Währung</xforms:label>
                </xs:appinfo>
                <xs:documentation>unit for monetary quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="minInclude" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Minimum</xforms:label>
                    <xforms:label xml:lang="en-US">Minimum</xforms:label>
                    <xforms:label xml:lang="de-DE">Minimum</xforms:label>
                </xs:appinfo>
                <xs:documentation>range min include for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxInclude" type="IntegerOrDecimalRange">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Maximum</xforms:label>
                    <xforms:label xml:lang="en-US">Maximum</xforms:label>
                    <xforms:label xml:lang="de-DE">Maximum</xforms:label>
                </xs:appinfo>
                <xs:documentation>range max include for quantities</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fractionDigits" type="FractionDigitsType">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Decimalen</xforms:label>
                    <xforms:label xml:lang="en-US">Digits</xforms:label>
                    <xforms:label xml:lang="de-DE">Ziffern</xforms:label>
                </xs:appinfo>
                <xs:documentation>fraction digits for quantities, e.g. "1" for at least 1 or "1!" for exactly 1</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeStampPrecision" type="DataSetTimeStampPrecision">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Tijdstempelprecisie</xforms:label>
                    <xforms:label xml:lang="en-US">Timestamp precision</xforms:label>
                    <xforms:label xml:lang="de-DE">Genauigkeit Zeitangabe</xforms:label>
                </xs:appinfo>
                <xs:documentation>precisions for timing specs</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Standard</xforms:label>
                    <xforms:label xml:lang="en-US">Default</xforms:label>
                    <xforms:label xml:lang="de-DE">Standard</xforms:label>
                </xs:appinfo>
                <xs:documentation>default value</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fixed" type="NonEmptyString">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Vast</xforms:label>
                    <xforms:label xml:lang="en-US">Fixed</xforms:label>
                    <xforms:label xml:lang="de-DE">Fest</xforms:label>
                </xs:appinfo>
                <xs:documentation>fixed value</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="minLength" type="SmallNonNegativeInteger">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Minimumlengte</xforms:label>
                    <xforms:label xml:lang="en-US">Minimum length</xforms:label>
                    <xforms:label xml:lang="de-DE">Minimum länge</xforms:label>
                </xs:appinfo>
                <xs:documentation>min length for strings</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="maxLength" type="SmallNonNegativeInteger">
            <xs:annotation>
                <xs:appinfo>
                    <xforms:label xml:lang="nl-NL">Maximumlengte</xforms:label>
                    <xforms:label xml:lang="en-US">Maximum length</xforms:label>
                    <xforms:label xml:lang="de-DE">Maximum länge</xforms:label>
                </xs:appinfo>
                <xs:documentation>max length for strings</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="DataSetTimeStampPrecision">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Value Domain Time Stamp Precision</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="Y">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="Y!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Jahr (JJJJ) und Monat (MM)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YM!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste dag (DD), maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">at least day (DD), month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Tag (TT), Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least day (DD), month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMD!">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">dag (DD), maand (MM) en jaar (JJJJ)</xforms:label>
                        <xforms:label xml:lang="en-US">day (DD), month (MM) and year (YYYY)</xforms:label>
                        <xforms:label xml:lang="de-DE">Tag (TT), Monat (MM) und Jahr (JJJJ)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">day (DD), month (MM) and year (YYYY)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="YMDHM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">tenminste dag (DD), maand (MM) en jaar (JJJJ), uur (uu) en minuut (mm)</xforms:label>
                        <xforms:label xml:lang="en-US">at least day (DD), month (MM) and year (YYYY), hour (hh) and minute (mm)</xforms:label>
                        <xforms:label xml:lang="de-DE">mindestens Tag (TT), Monat (MM) und Jahr (JJJJ), Stunde (ss) und Minute (mm)</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">at least day (DD), month (MM) and year (YYYY), hour (hh) and minute (mm)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="DataSetValueType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept Value Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="count">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Aantal</xforms:label>
                        <xforms:label xml:lang="en-US">Count</xforms:label>
                        <xforms:label xml:lang="de-DE">Count</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Countable (non-monetary) quantities. Used for countable types such as pregnancies, steps (taken by a physiotherapy patient), number of cigarettes
                        smoked in a day.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="code">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Code</xforms:label>
                        <xforms:label xml:lang="en-US">Code</xforms:label>
                        <xforms:label xml:lang="de-DE">Kode</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A system of valid symbols that substitute for specified concepts e.g. alpha, numeric, symbols and/or combinations, usually defined by a formal
                        reference to a terminology or ontology, but may also be defined by the provision of text.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ordinal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ordinaal</xforms:label>
                        <xforms:label xml:lang="en-US">Ordinal</xforms:label>
                        <xforms:label xml:lang="de-DE">Ordinal</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Models rankings and scores, e.g. pain, Apgar, reflex, ASA, Tanner values, etc, where there is a) implied ordering, b) no implication that the
                        distance between each value is con- stant, and c) the total number of values is finite. Note that although the term ‘ordinal’ in mathematics means natural numbers only, here
                        any integer is allowed, since negative and zero values are often used by medical professionals for values around a neutral point.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="identifier">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Identificatie</xforms:label>
                        <xforms:label xml:lang="en-US">Identifier</xforms:label>
                        <xforms:label xml:lang="de-DE">Identifier</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Type for representing identifiers of real-world entities. Typical identifiers include drivers licence number, social security number,
                        prescription id, order id, and so on.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="string">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">String</xforms:label>
                        <xforms:label xml:lang="en-US">String</xforms:label>
                        <xforms:label xml:lang="de-DE">String</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Plain text without markup</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="text">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Tekst</xforms:label>
                        <xforms:label xml:lang="en-US">Text</xforms:label>
                        <xforms:label xml:lang="de-DE">Tekst</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A text item, which may contain any amount of legal characters arranged as e.g. words, sentences etc. Visual formatting and hyperlinks may be
                        included.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="date">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Datum</xforms:label>
                        <xforms:label xml:lang="en-US">Date</xforms:label>
                        <xforms:label xml:lang="de-DE">Datum</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Represents an absolute point in time, as measured on the Gregorian calendar, and specified only to the day. Semantics defined by ISO 8601. Used
                        for recording dates in real world time. The partial form is used for approximate birth dates, dates of death, etc.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="datetime">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Datum+tijd</xforms:label>
                        <xforms:label xml:lang="en-US">Date+time</xforms:label>
                        <xforms:label xml:lang="de-DE">Datum+Zeit</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Represents an absolute point in time, specified to the second. Semantics defined by ISO 8601. Used for recording a precise point in real world
                        time, e.g. the exact date and time of the birth of a baby, and for approximate time stamps, e.g. the origin of an history observation which is only partially
                        known.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="complex">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Samengestelde gegevens</xforms:label>
                        <xforms:label xml:lang="en-US">Collection of data</xforms:label>
                        <xforms:label xml:lang="de-DE">Zusammenstellung von Daten</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">collection of data, e.g. complex specification as part of dosage instructions, a person's name (if not further specified)</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="quantity">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoeveelheid</xforms:label>
                        <xforms:label xml:lang="en-US">Quantity</xforms:label>
                        <xforms:label xml:lang="de-DE">Anzahl</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Quantitified type representing "scientific" quantities, i.e. quantities expressed as a magnitude and units. For time durations duration shall be
                        used; for monetary amounts currency shall be used (not yet available, currently use 'quantity')</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="duration">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Tijdsduur</xforms:label>
                        <xforms:label xml:lang="en-US">Duration</xforms:label>
                        <xforms:label xml:lang="de-DE">Zeitraum</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Is a quantity, represents a period of time with respect to a notional point in time, which is not specified. A sign may be used to indicate the
                        duration is “backwards” in time rather than forwards.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="boolean">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Boolean</xforms:label>
                        <xforms:label xml:lang="en-US">Boolean</xforms:label>
                        <xforms:label xml:lang="de-DE">Boolean</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Items which are truly boolean data, such as true/false or yes/no answers.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="blob">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Binair</xforms:label>
                        <xforms:label xml:lang="en-US">Binary</xforms:label>
                        <xforms:label xml:lang="de-DE">Binary</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Things that are typically stored as binary objects in the computer world and need to be rendered appropriately, e.g. images: like X-rays,
                        computertomographic images and scans.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="decimal">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Decimaal getal</xforms:label>
                        <xforms:label xml:lang="en-US">Decimal number</xforms:label>
                        <xforms:label xml:lang="de-DE">Dezimalzahl</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Decimal number (rarely used, in most cases a decimal number is actually a quantity).</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DataSetConcept">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept, is either a group or an item.</xs:documentation>
            <xs:documentation xml:lang="en-US">A group may contain other groups or items and does not contain a operationalizations or value domain definitions</xs:documentation>
            <xs:documentation xml:lang="en-US">An item typically has operationalizations and value domain definitions and may not contain a concept</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Data Concept</sch:title>
                    <sch:rule context="dataset//concept[not(ancestor::history|parent::conceptList|ancestor::dataset[@statusCode='final'])]">
                        
                        <!-- @id is always required! -->

                        <!-- if not inherit/@ref then @type and @statusCode SHALL be present -->
                        <sch:assert test="inherit/@ref or @type">ERROR: If concept is not inherited then @type SHALL be present.</sch:assert>
                        <!--sch:assert test="inherit/@ref or @statusCode">ERROR: If concept is not inherited then @statusCode SHALL be present.</sch:assert-->

                        <!-- if inherit/@ref then @effectiveDate is required -->
                        <sch:assert test="not(inherit/@ref) or (inherit/@ref and @effectiveDate)">ERROR: If concept has a inherit/@ref then @effectiveDate SHALL be present.</sch:assert>

                        <!-- if inherit/@ref then @type is prohibited -->
                        <sch:assert test="not(inherit/@ref) or not(@type)">ERROR: If concept is inherited then @type SHALL NOT be present.</sch:assert>

                        <!-- if not inherit then name and desc SHALL be present-->
                        <sch:assert test="inherit or (name and desc)">ERROR: If concept has an @id then name and desc SHALL be present.</sch:assert>

                        <!-- if inherit/@ref then child elements except comment or concept or rationale SHALL NOT be present -->
                        <sch:assert test="not(inherit/@ref) or count(* except (comment|concept|rationale|inherit|history))=0">ERROR: If concept has a inherit/@ref, child elements except comment, concept, history or rationale SHALL NOT be present.</sch:assert>

                        <!--
                        <sch:assert test="string-length(name)>1">ERROR: concept/name SHALL be a short string.</sch:assert>
                        <sch:assert test="string-length(desc)>1">ERROR: concept/name SHALL be a short string.</sch:assert>
                        -->
                        <sch:let name="inhcid" value="inherit/@ref"/>
                        <sch:let name="inhced" value="inherit/@effectiveDate"/>
                        <sch:let name="inhc" value="//dataset//concept[@id=$inhcid][@effectiveDate=$inhced][not(ancestor::history|parent::conceptList)]"/>
                        <sch:let name="inhctype" value="$inhc/@type"/>
                        <sch:let name="ctype" value="if (.[@type]) then (@type) else if (count($inhctype)=1 and $inhc/concept and string-length($inhctype)&gt;0) then ($inhctype) else ('')"/>
                        <sch:assert role="error" test="($ctype='group' and count(concept)&gt;0 and count(valueDomain)=0) or not($ctype='group')">ERROR: A concept of (inherited) type group SHOULD have concept child definition(s).</sch:assert>
                        <sch:assert role="error" test="($ctype='item' and count(concept)=0) or not($ctype='item')">ERROR: A concept of (inherited) type item SHOULD NOT have concept child definition(s).</sch:assert>
                        <sch:assert role="error" test="not(string-join($inhctype,'')='item' and count(valueDomain)&gt;0)">ERROR: A concept of inherited type item SHOULD NOT have a value domain definition.</sch:assert>
                        <sch:report role="warning" test="@type='item' and count(valueDomain[@type])=0 and count(inherit)=0">WARNING: A concept of type item SHOULD have a value domain with a type definition.</sch:report>
                        <sch:assert test="count($inhctype) &lt;= 1">ERROR: Concept id <sch:value-of select="@id"/> and effective date <sch:value-of select="@effectiveDate"/> has ambiguous inheritance as the concept it inherits from is a duplicate.</sch:assert>
                        <sch:let name="cid" value="@id"/>
                        <sch:let name="ced" value="@effectiveDate"/>
                        <sch:let name="cnm" value="if (inherit[@ref]) then ($inhc/name/text())[1] else (name[1]/text())"/>
                        <sch:let name="isInTransaction" value="//representingTemplate[@ref]/concept[@ref=$cid][ancestor::transaction/@statusCode=('draft','final')][ancestor::scenario/@statusCode=('draft','final')]"/>
                        <sch:let name="isInTemplate" value="//rules/templateAssociation/concept[@ref=$cid][not(@effectiveDate) or @effectiveDate=$ced]"/>
                        <sch:let name="rulesDefined" value="//rules[template]"/>
                        <sch:assert role="warning" test="not($isInTransaction) or $isInTemplate or not($rulesDefined)">WARNING: concept <sch:value-of select="$ctype"/> with conceptId '<sch:value-of select="$cid"/>' ('<sch:value-of select="$cnm"/>') is used in at least one transaction, but does not have a templateAssociation</sch:assert>
                        
                        <sch:let name="inhconcept" value="(//datasets/dataset//concept[@id=$inhcid][string-length($inhced)>0 or @effectiveDate=$inhced][not(ancestor-or-self::history|parent::conceptList)])[1]"/>
                        <sch:assert role="error" test="not(inherit) or not($inhconcept/inherit)"
                            >ERROR: A concept SHALL NOT inherit from a concept that inherits. It MUST inherit from the original concept ref="<sch:value-of select="$inhconcept/inherit/@ref"/>" effectiveDate="<sch:value-of select="$inhconcept/inherit/@effectiveDate"/>"</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept inherits properties from another concept</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Name (short). One name per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="synonym" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Synonym for a Data Set Concept Name (short). Can have multiple synonyms per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Description (long). One to many descriptions per language</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="source" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Source, human readable hint where this data element originally comes from</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="rationale" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set rationale, human readable justification or explanation why this concept is present</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="comment" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Comments</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- following elements for type item only -->
            <xs:element name="operationalization" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Operationalization, e.g. how to measure, obtain, specify the value of an observation</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="valueDomain" type="DataSetConceptValue" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept Value Domain, properties of the value in an instance</xs:documentation>
                </xs:annotation>
            </xs:element>

            <!-- following elements for type group only -->
            <xs:element name="concept" type="DataSetConcept" minOccurs="0" maxOccurs="unbounded"/>

            <!-- history -->
            <xs:element name="history" type="DataSetConceptHistory" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Data Set Concept History</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <!--
            attributes checked by schematrons, see above
        -->
        <xs:attribute name="id" type="Oid" use="required"/>
        <xs:attributeGroup ref="VersionHandling"/>
        <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
        <xs:attribute name="type" type="DataSetConceptType" use="optional"/>
    </xs:complexType>
    <xs:complexType name="DataSetConceptHistory">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept History of either a group or an item.</xs:documentation>
            <xs:documentation xml:lang="en-US">A Concept History may not contain nested history items</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="DataSetConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="validTimeHigh" use="required" type="TimeStampNoTimezone">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The time that the given information ceased to be correct.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="DataSetConceptType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Concept Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="group">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Groep</xforms:label>
                        <xforms:label xml:lang="en-US">Group</xforms:label>
                        <xforms:label xml:lang="de-DE">Gruppe</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">group of data set items</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">groep van data set items</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Gruppe von Dataset-Items</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="item">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Item</xforms:label>
                        <xforms:label xml:lang="en-US">Item</xforms:label>
                        <xforms:label xml:lang="de-DE">Item</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">data set item</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">datasetitem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Dataset-Item</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ProcessCode">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of processing</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="strict">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Strikt</xforms:label>
                        <xforms:label xml:lang="en-US">Strict</xforms:label>
                        <xforms:label xml:lang="de-DE">Strikt</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="lax">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Los</xforms:label>
                        <xforms:label xml:lang="en-US">Lax</xforms:label>
                        <xforms:label xml:lang="de-DE">Locker</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ItemStatusCodeLifeCycle">
        <!-- 
            o - > new- - > draft - - > final - - - > o
             \
              \  - - - > rejected
               \ - - - > cancelled
                \ - - -> deprecated
                
            
               
            (approved) and (implemented) are under approvals
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">LifeCycle of the Status Code of a Data Set Item</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="new">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Nieuw</xforms:label>
                        <xforms:label xml:lang="en-US">New</xforms:label>
                        <xforms:label xml:lang="de-DE">Neu</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">item just created and is new and work in progress to become a draft/finalized item/issue. Beyond the author, nobody should look at this
                        item/issue unless it's status code is draft or finalized.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="draft">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontwerp</xforms:label>
                        <xforms:label xml:lang="en-US">Draft</xforms:label>
                        <xforms:label xml:lang="de-DE">Entwurf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">item is draft</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="final">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Definitief</xforms:label>
                        <xforms:label xml:lang="en-US">Final</xforms:label>
                        <xforms:label xml:lang="de-DE">Definitiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">item finalized, ready for approval</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="rejected">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgewezen</xforms:label>
                        <xforms:label xml:lang="en-US">Rejected</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgewiesen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">item is rejected</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">item is cancelled</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="deprecated">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Verouderd</xforms:label>
                        <xforms:label xml:lang="en-US">Deprecated</xforms:label>
                        <xforms:label xml:lang="de-DE">Veraltet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">item is deprecated, i.e. item should be avoided to be used, typically because it will be or has been superseded</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="TemplateStatusCodeLifeCycle">
        <!-- 
            template status (see also HL7 Templates Business Process Requirements Analysis as of January 2012)
            
            Nascent: Under development. Metadata and template may be incomplete. Entered primarily to encourage other users to be aware of ongoing process.
            
            Active: Has been published by the custodian organization and deemed fit for use. May have associated adoption and annotation metadata.
            
            Inactive: Never recommended for use. For example, rejected, withdrawn or found another template fit for use of the one under development. 
            Will not have associated adoption metadata.
            
            Under Update (adoption metadata): adopter adds adoption metadata and/or grouping metadata: these are the only actions an adopter 
            organization can perform. The template(s) in the “under update (adoption metadata” status are unavailable for any other status or 
            metadata changes until the “under update (adoption metadata” action has been completed.
            
            Pre-publication review: the template is complete, pending appropriate review. Entered primarily to encourage other users to be 
            aware of and/or participate in the review process. The custodian organization has not given it an “Active” status (i.e. it has
            not been published); and it may still be rejected (transitioned to an inactive status). E.g. the template may be under ballot by an SDO.
            
            In Review: a post-publication state; may result in a new version or a retirement or no change at all. A new version is one that
            adds clarity but not new intent; the version number is incremented by one, but the identifier is unchanged. A retirement is a 
            template that is no longer fit for purpose, and which may be replaced by a different a template with a different identifier, 
            which is linked to the retired template.
            
            Retired: No longer fit for use. Information available for historical reference.
            
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">LifeCycle of the Status Code of a Template</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="draft">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontwerp</xforms:label>
                        <xforms:label xml:lang="en-US">Draft</xforms:label>
                        <xforms:label xml:lang="de-DE">Entwurf</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template under development (nascent). Metadata and template may be incomplete. Entered primarily to encourage other users to be aware of ongoing
                        process.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="active">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Actief</xforms:label>
                        <xforms:label xml:lang="en-US">Active</xforms:label>
                        <xforms:label xml:lang="de-DE">Aktiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template has been published by the governance group (custodian organization) and deemed fit for use. May have associated adoption and annotation metadata.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="retired">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Obsoleet</xforms:label>
                        <xforms:label xml:lang="en-US">Retired</xforms:label>
                        <xforms:label xml:lang="de-DE">Obsolet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template retired: No longer fit for use. Information available for historical reference.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 
                the following states are not really used by template repositories but serve as template registry metadata
            -->
            <xs:enumeration value="inactive">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Inactief</xforms:label>
                        <xforms:label xml:lang="en-US">inactive</xforms:label>
                        <xforms:label xml:lang="de-DE">Inaktiv</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template was published but never recommended for use. For example, rejected, withdrawn or found another template fit for use of the one under development. Will not
                        have associated adoption metadata. </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="rejected">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgewezen</xforms:label>
                        <xforms:label xml:lang="en-US">Rejected</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgewiesen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is rejected. During the development proces of a template design (new, draft) it was decided that
                        further development on this template will not happen.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template was never published and is withdrawn.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="update">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">In bewerking</xforms:label>
                        <xforms:label xml:lang="en-US">Under update</xforms:label>
                        <xforms:label xml:lang="de-DE">In Bearbeitung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is undergoing an update (adoption metadata): adopter adds adoption metadata and/or grouping metadata: these are the only actions an adopter
                        organization can perform. The template(s) in the "under update (adoption metadata)" status are unavailable for any other status or metadata changes until the "under update
                        (adoption metadata)" action has been completed.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="pending">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Onder revisie vóór de publicatie</xforms:label>
                        <xforms:label xml:lang="en-US">Under pre-publication review</xforms:label>
                        <xforms:label xml:lang="de-DE">Unter Revision vor der Publikation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is in pre-publication review: the template is complete, pending appropriate review. Entered primarily to encourage other users to be
                        aware of and/or participate in the review process. The governance group (custodian organization) has not given it an "active" status (i.e. it has not been published); 
                        and it may still be rejected (transitioned to an inactive status)., e.g. the template may be under ballot by an SDO.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="review">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Wordt gereviewed</xforms:label>
                        <xforms:label xml:lang="en-US">In Review</xforms:label>
                        <xforms:label xml:lang="de-DE">In Revision</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template is in review: a post-publication state; may result in a new version or a retirement or no change at all. 
                        A new version is one that adds clarity but not new intent (new version date but identifier is unchanged).
                        A retirement is a template that is no longer fit for purpose, and which
                        may be replaced by a different a template (version), which is linked to the retired template.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="DataSetConceptList">
        <xs:annotation>
            <xs:appinfo>
                <!--sch:pattern name="Validate ConceptList TerminologyAssociation">
                    <sch:rule context="dataset//conceptList[@id]">
                        <sch:let name="pcId" value="(ancestor::concept)[1]/@id"/>
                        <sch:let name="pcType" value="(ancestor::valueDomain)[1]/@type"/>
                        <sch:let name="cId" value="@id"/>
                        <sch:assert role="warning" test="not($pcType='code') or //terminology/terminologyAssociation[@conceptId=$cId]"
                            >WARNING: The concept list <sch:value-of select="$cId"/> inside concept item <sch:value-of select="$pcId"/> SHOULD have a terminologyAssociation</sch:assert>
                    </sch:rule>
                </sch:pattern-->
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="DataSetConceptListConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this conceptList and may be used to reference it. Concept lists SHOULD carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="Oid">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a conceptList/@id. Concept lists SHOULD carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="DataSetConceptListConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Concept TerminologyAssociation</sch:title>
                    <sch:rule context="dataset//conceptList[not(ancestor::history)][not(ancestor::*/@statusCode=('deprecated','cancelled','rejected'))]/concept[@id]">
                        <sch:let name="pcId" value="ancestor::concept[1]/@id"/>
                        <sch:let name="clId" value="parent::conceptList/@id"/>
                        <sch:let name="clHasTermAssoc" value="//terminologyAssociation[@conceptId=$clId]"/>
                        <sch:let name="cId" value="@id"/>
                        <sch:let name="cHasTermAssoc" value="//terminologyAssociation[@conceptId=$cId]"/>
                        <sch:assert role="warning" test="not(exists($clHasTermAssoc)) or exists($cHasTermAssoc)"
                            >WARNING: The concept <sch:value-of select="$cId"/> SHOULD have a terminologyAssociation as the conceptList has a valueSet binding</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
            <xs:element name="synonym" type="BusinessNameWithLanguage" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Synonym for a Data Set Concept List Item Name (short). Can have multiple synonyms per language.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional"/>
        <xs:attribute name="exception" type="xs:boolean">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">indicates whether this is an exceptional concept (for example: unknown)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="scenarios">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="actors" type="ActorsDefinition" minOccurs="1" maxOccurs="1"/>
                <xs:element ref="scenario" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="instances" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="instances">
        <xs:complexType>
            <xs:sequence>
                <xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="displayName" type="ShortDescriptiveName" use="optional"/>
            <xs:attribute name="effectiveDate" type="TimeStampNoTimezone"  use="required"/>
            <xs:attribute name="ref" type="Oid" use="required"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
            <xs:attribute name="process" type="ProcessCode"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="scenario">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="trigger" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="condition" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="transaction" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <!-- Deprecated. Having a name element and a @displayName attribute makes no sense. Was not in use at deprecation time -->
            <!--xs:attribute name="displayName" type="ShortDescriptiveName" use="optional"/-->
            <xs:attribute name="id" use="required" type="Oid"/>
            <xs:attributeGroup ref="VersionHandling"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="transaction">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Transaction group or singular transaction</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate Transaction</sch:title>
                        <sch:rule context="scenario//transaction">
                            <sch:assert test="not(@model) or @type">ERROR: A transaction with an underlying model SHALL have a @type</sch:assert>
                            <!--<sch:assert test="not(@type='group' and (@effectiveDate or @statusCode))">ERROR: Transaction group SHALL NOT have version attributes @effectiveDate and @statusCode</sch:assert>
                            <sch:assert test="@type='group' or (@effectiveDate and @statusCode)">ERROR: Transaction item SHALL have version attributes @effectiveDate and @statusCode</sch:assert>-->
                            <sch:assert role="error" test="(@effectiveDate and @statusCode)"
                                >ERROR: Transaction SHALL have version attributes @effectiveDate and @statusCode</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence minOccurs="0">
                <xs:sequence>
                    <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
                    <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="trigger" type="TransactionTrigger" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="condition" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="dependencies" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
                </xs:sequence>
                <xs:choice>
                    <xs:sequence>
                        <xs:element name="actors" type="ActorsReference" minOccurs="1" maxOccurs="1"/>
                        <xs:element ref="representingTemplate" minOccurs="0"/>
                    </xs:sequence>
                    <xs:element ref="transaction" minOccurs="0" maxOccurs="unbounded"/>
                </xs:choice>
            </xs:sequence>
            <!-- Deprecated. Having a name element and a @displayName attribute makes no sense. Was not in use at deprecation time -->
            <!--xs:attribute name="displayName" type="ShortDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Display name for this transaction</xs:documentation>
                </xs:annotation>
            </xs:attribute-->
            <xs:attribute name="id" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Globally and persistently unique identifier</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="model" type="xs:NCName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Root element name for the XML structure without namespace prefix that represents this transaction. For HL7 messaging this could be REPC_IN004410UV</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="label" type="xs:NCName">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Constitutes the value for the schematron file with the project prefix (//project/@prefix)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="TransactionType" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="TransactionTrigger">
        <xs:complexContent mixed="true">
            <xs:extension base="FreeFormMarkupWithLanguage">
                <xs:attribute name="id" use="optional" type="xs:NCName"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <xs:simpleType name="TransactionType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Allows specification of the type of a transaction.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationString">
            <xs:enumeration value="group">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Groep</xforms:label>
                        <xforms:label xml:lang="en-US">Group</xforms:label>
                        <xforms:label xml:lang="de-DE">Gruppe</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type group</sch:title>
                            <sch:rule context="transaction[@type='group']" id="TransactionTypeGroup">
                                <sch:assert test="parent::*[1][local-name()='scenario']"> ERROR: Transaction groups SHALL be immediate children of scenario.</sch:assert>
                                <sch:assert test="not(.//transaction[@type='group'])"> ERROR: Transaction groups SHALL NOT contain transaction groups.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'group' groups transactions of other types</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="initial">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Initieel</xforms:label>
                        <xforms:label xml:lang="en-US">Initial</xforms:label>
                        <xforms:label xml:lang="de-DE">Initial</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type initial</sch:title>
                            <sch:rule context="transaction[@type='initial']" id="TransactionTypeInitial">
                                <sch:assert test="parent::*[1][local-name()='transaction'][@type='group']"> ERROR: Transactions of type 'initial' SHALL be immediate children of a transaction
                                    group.</sch:assert>
                                <sch:assert test="count(actors/actor[@role='sender']) &gt;=1 and count(actors/actor[@role='receiver']) &gt;=1"> ERROR: Transactions of type 'initial' SHALL have at
                                    least 1 'sender' actor and at least 1 'receiver' actor.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'initial' says that this is the transaction that is initially sent, and usually invokes a response. This transaction type
                        requires at least a 'sender' and a 'receiver' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="back">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Terug</xforms:label>
                        <xforms:label xml:lang="en-US">Back</xforms:label>
                        <xforms:label xml:lang="de-DE">Zurück</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type back</sch:title>
                            <sch:rule context="transaction[@type='back']" id="TransactionTypeBack">
                                <sch:assert test="parent::*[1][local-name()='transaction'][@type='group']"> ERROR: Transactions of type 'back' SHALL be immediate children of a transaction
                                    group.</sch:assert>
                                <sch:assert test="preceding-sibling::transaction[@type='initial']"> ERROR: Transactions of type 'back' SHALL be preceded by a transaction of type
                                    'initial'.</sch:assert>
                                <sch:assert test="count(actors/actor[@role='sender']) &gt;=1 and count(actors/actor[@role='receiver']) &gt;=1"> ERROR: Transactions of type 'back' SHALL have at least 1
                                    'sender' actor and at least 1 'receiver' actor.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'back' says that this transaction is sent in response to another transaction that preceded this one. Transactions of type
                        'back' may invoke a new transaction, but this is again of type initial. This transaction type requires at least a 'sender' and a 'receiver' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stationary">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Stationair</xforms:label>
                        <xforms:label xml:lang="en-US">Stationary</xforms:label>
                        <xforms:label xml:lang="de-DE">Stationär</xforms:label>
                    </xs:appinfo>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Transaction Type stationary</sch:title>
                            <sch:rule context="transaction[@type='stationary']" id="TransactionTypeStationary">
                                <sch:assert test="parent::*[1][local-name()='transaction'][@type='group']"> ERROR: Transactions of type 'stationary' SHALL be immediate children of a transaction
                                    group.</sch:assert>
                                <sch:assert test="not(following-sibling::transaction[position()=1][@type='back'])"> ERROR: Transactions of type 'stationary' SHALL NOT be followed by a transaction of
                                    type 'back'.</sch:assert>
                                <sch:assert test="count(actors/actor[@role='sender'])=1 and count(actors/actor)=1"> ERROR: Transactions of type 'stationary' SHALL have exactly 1 actor of type
                                    'sender'.</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">A transaction of type 'stationary' says that this transaction does not involve communication, but rather the local registration/administration of
                        data. Transactions of type 'stationary' do not invoke new transaction. This transaction type requires exactly one 'sender' actor.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActorsDefinition">
        <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" name="actor" type="ActorDefinition"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ActorsReference">
        <xs:sequence>
            <xs:element minOccurs="1" maxOccurs="unbounded" name="actor" type="ActorReference"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ActorDefinition">
        <xs:sequence>
            <xs:element name="name" type="BusinessNameWithLanguage" minOccurs="1" maxOccurs="unbounded"/>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="required"/>
        <xs:attribute name="type" type="ScenarioActorType" use="required"/>
        <!-- 2DO should be person|device etc -->
    </xs:complexType>
    <xs:simpleType name="ScenarioActorType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Actor type for use in scenarios and transactions</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="person">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Persoon</xforms:label>
                        <xforms:label xml:lang="en-US">Person</xforms:label>
                        <xforms:label xml:lang="de-DE">Person</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Person</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="organization">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Organisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Organization</xforms:label>
                        <xforms:label xml:lang="de-DE">Organisation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Organization</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="device">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Systeem</xforms:label>
                        <xforms:label xml:lang="en-US">Device</xforms:label>
                        <xforms:label xml:lang="de-DE">Gerät</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Device</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="ActorReference">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Actor reference references an actor that is defined in the main list of actors for all scenarios</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Actor Reference</sch:title>
                    <sch:rule context="transaction/actors/actor">
                        <sch:let name="actorId" value="@id"/>
                        <sch:assert test="ancestor::scenarios/actors/actor[@id=$actorId]"
                            >ERROR: An actor reference SHALL reference an actor in the main list of actors for all scenarios. <sch:value-of select="$actorId"/> does not exist</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="id" use="required" type="Oid"/>
        <xs:attribute name="role" type="ActorType"/>
    </xs:complexType>
    <xs:simpleType name="ActorType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Type of role the actor plays in a transaction</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="sender">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Zender</xforms:label>
                        <xforms:label xml:lang="en-US">Sender</xforms:label>
                        <xforms:label xml:lang="de-DE">Sender</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the sender of the transaction</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="receiver">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Ontvanger</xforms:label>
                        <xforms:label xml:lang="en-US">Receiver</xforms:label>
                        <xforms:label xml:lang="de-DE">Empfänger</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the receiver of the transaction</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="stationary">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Stationair</xforms:label>
                        <xforms:label xml:lang="en-US">Stationary</xforms:label>
                        <xforms:label xml:lang="de-DE">Stationär</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This actor is the person or device responsible for persisting the data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="representingTemplate">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate sourceDataset with concepts</sch:title>
                        <sch:rule context="scenario[@statusCode=('draft','final','new')]//representingTemplate[@ref]">
                            <sch:let name="ref" value="@ref"/>
                            <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max(//rules/template[@id=$ref or @name=$ref]/xs:dateTime(@effectiveDate)))"/>
                            <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                            <sch:let name="representingTemplateExists" value="exists(//rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility])"/>
                            <sch:assert test="count(concept) = 0 or string-length(@sourceDataset)&gt;0">ERROR: if a representing template contains concept references, a sourceDataset SHALL be present</sch:assert>
                            <sch:assert test="not(@ref) or $representingTemplateExists">ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' MUST point to an existing template with flexibility '<sch:value-of select="$flextext"/>'</sch:assert>
                            <sch:assert test="not(@ref) or not($representingTemplateExists) or //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][context]">ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' MUST point to an existing template with a context element</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element name="concept" minOccurs="0" maxOccurs="unbounded" type="ScenarioTemplateConcept"/>
            </xs:sequence>
            <!-- Attributes -->
            <xs:attribute name="ref" type="xs:anyURI" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a template/@id or template/@name that sets the structure and rules for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility" default="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Static or dynamic (which is the default) flexibility to the template/@id given in @ref.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="displayName" type="LongDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Display name for this representingTemplate</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="sourceDataset" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a dataset/@id that holds the concept definitions for the concepts in this representingTemplate.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
        <xs:unique name="uniqueConceptsInRepresentingTemplate">
            <xs:selector xpath="./concept"/>
            <xs:field xpath="@ref"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="ScenarioTemplateConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate scenario</sch:title>
                    <sch:rule context="scenario[@statusCode=('draft','final','new')]//representingTemplate/concept">
                        <sch:assert role="error" test="not(@isMandatory='true' and @minimumMultiplicity='0')"
                            >ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        <sch:assert role="error" test="not(condition[@isMandatory='true' and @minimumMultiplicity='0'])"
                            >ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        
                        <sch:assert test="(@minimumMultiplicity or @maximumMultiplicity or @conformance='NP') or (@conformance='C' and count(condition)&gt;0)"
                            >ERROR: a representing template concept SHALL contain cardinality or conditions</sch:assert>
                        <sch:report role="warning" test="@conformance='C' and count(condition)=0"
                            >WARNING: a conditional representing template concept SHOULD contain conditions</sch:report>
                        <sch:report role="warning" test="@conformance='C' and (@minimumMultiplicity or @maximumMultiplicity)"
                            >WARNING: a conditional representing template concept SHOULD have the @minimumMultiplicity and/or @maximumMultiplicity on its conditions</sch:report>
                        <sch:let name="dsid" value="parent::*/@sourceDataset"/>
                        <sch:let name="cid" value="@ref"/>
                        <sch:assert test="//datasets/dataset[@id=$dsid]//concept[not(parent::conceptList)][@id=$cid]"
                            >ERROR: concept/@id='<sch:value-of select="$cid"/>' MUST exist in dataset/@id='<sch:value-of select="$dsid"/>'</sch:assert>

                        <!-- Scenario currently has statusCode and transaction currently doesn't. Check should still work if transaction is to have a statusCode -->
                        <sch:let name="cptStatus" value="//datasets/dataset[@id=$dsid]//concept[@id=$cid][not(parent::conceptList)][not(ancestor::history)]/@statusCode"/>
                        <sch:assert role="warning" test="$cptStatus=('new','draft','final') or not(ancestor::*[@statusCode=('new','draft')]) or string-length($cptStatus)=0"
                            >WARNING: concept/@id='<sch:value-of select="$cid"/>' SHOULD, while you may still edit it, point to a new, draft or final concept, but found '<sch:value-of select="$cptStatus"/>'</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="condition" type="ScenarioTemplateCondition" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="ref" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@id that is not in history or in a concept list, and is in the dataset that the representing template refers to.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:complexType name="ScenarioTemplateCondition" mixed="true">
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
    </xs:complexType>
    <xs:element name="ids">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="baseId" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defaultBaseId" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="id" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="identifierAssociation" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="baseId">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate baseId</sch:title>
                        <sch:rule context="baseId">
                            <sch:assert test="substring(@prefix, string-length(@prefix), 1)='-'">ERROR: baseId prefix SHALL end with "-".</sch:assert>
                            
                            <sch:let name="baseId" value="@id"/>
                            <sch:let name="baseType" value="@type"/>
                            <!--
                                We're in transition some project will be old style, some new.
                                Old style:
                                    <baseId id="1.2.3" type="DS" prefix="xyz"/>
                                    <defaultBaseId id="1.2.3" type="DS"/>
                                New style:
                                    <baseId id="1.2.3" type="DS" prefix="xyz" default="true"/>
                            -->
                            <!--Support old style-->
                            <sch:assert role="error" test="not(../defaultBaseId) or count(parent::ids/defaultBaseId[@type=$baseType])=1">ERROR: Exactly one of type '<sch:value-of select="$baseType"/>' SHALL be marked as default base id</sch:assert>
                            <!--Support new style-->
                            <sch:assert role="error" test="../defaultBaseId or count(parent::ids/baseId[@type=$baseType][@default='true'])=1">ERROR: Exactly one of type '<sch:value-of select="$baseType"/>' SHALL be marked with @default='true'</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="type" type="DecorObjectType" use="required"/>
            <xs:attribute name="prefix" type="ShortDescriptiveName" use="required"/>
            <xs:attribute name="default" type="xs:boolean" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines whether or not this baseId is the default for its @type. There SHALL be exactly only one per type with @default='true'</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="defaultBaseId">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate defaultBaseId type</sch:title>
                        <sch:rule context="defaultBaseId">
                            <sch:let name="dbt" value="@type"/>
                            <sch:assert test="count(preceding-sibling::defaultBaseId[@type = $dbt])=0">ERROR: defaultBaseId type SHALL be unique with project.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:attribute name="id" type="Oid" use="required"/>
            <xs:attribute name="type" type="DecorObjectType" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="id">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="designation" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="root" type="Oid"/>
            <xs:attribute name="extension" type="EnumerationString"/>
            <xs:attribute name="assigningAuthority" type="LongDescriptiveName"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="identifierAssociation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">identifierAssociation links a dataset conceptList to an identifier scheme. Any conceptList may have multiple of these associations</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate identifierAssociation</sch:title>
                        <sch:rule context="identifierAssociation[not(@expirationDate)]">
                            <sch:let name="projectId" value="(//project/@id)[1]"/>
                            <sch:let name="conceptId" value="@conceptId"/>
                            <!-- In inheritance situations from another project, there is no conceptList in this project, so skip check if conceptList id is not from this project -->
                            <sch:assert role="warning" test="//datasets/dataset//conceptList[@id=$conceptId][parent::valueDomain/@type=('identifier')] or not(starts-with($conceptId,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' SHOULD point to an existing conceptList under a value domain of type identifier</sch:assert>
                            
                            <sch:assert role="error" test="not(//terminologyAssociation[@conceptId=$conceptId])"
                                >ERROR: co-occurrence violation. A concept(List) MUST NOT be associated with terminology AND an identifier scheme</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <!--<xs:attribute name="id" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">each assignment MUST have a project unique id so you can attach issues, change with precision, and potentially delete</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            <xs:attribute name="conceptId" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">conceptList id this assocication is associated with, applies always to all conceptLists with that id or ref, regardless of its effectiveDate or statusCode</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" use="required" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Object Identifier (OID) of the identification scheme this assocication is associated with. Example: '2.16.840.1.113883.4.1' for US Social Security Numbers</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- version handling -->
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <!-- removed after talks with users: not relevant for now and a can of worms should want it -->
            <!--<xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">manages the status of the association itself</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
        </xs:complexType>
    </xs:element>
    <xs:element name="issues">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate issues ids</sch:title>
                        <sch:rule context="issue">
                            <sch:let name="iid" value="@id"/>
                            <sch:assert test="count(preceding-sibling::issue[@id = $iid])=0">ERROR: issue id SHALL be unique with project.</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:sequence>
                <xs:element ref="labels" minOccurs="0" maxOccurs="1"/>
                <xs:element ref="issue" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="notifier" type="NotifierOnOff" use="optional" default="on">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Specifies whether the automatic notifier system (if activated) should notify all authors of the project about changes of any project issue. Default is "on"</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="NotifierOnOff">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Automatic notifier system (if activated) notifies all authors of the project about changes of any project issue on/off</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="on">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Notifier on</xforms:label>
                        <xforms:label xml:lang="en-US">Notifier on</xforms:label>
                        <xforms:label xml:lang="de-DE">Notifier on</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Notifier on</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="off">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Notifier off</xforms:label>
                        <xforms:label xml:lang="en-US">Notifier off</xforms:label>
                        <xforms:label xml:lang="de-DE">Notifier off</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Notifier off</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="labels">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Contains definition of labels specific to this DECOR instance. A DECOR instance does require labeling of issues. 
                However once a label is used you SHOULD NOT alter/remove the label.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="label" minOccurs="1" maxOccurs="unbounded" type="IssueLabelDefinition"/>
            </xs:sequence>
        </xs:complexType>
        <xs:unique name="uniqueLabelCode">
            <xs:selector xpath=".//label"/>
            <xs:field xpath="./@code"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="IssueLabelDefinition">
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Describes what the label is meant to represent/do</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="color" type="HTMLColorName" use="optional" default="white">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains an HTML compatible reference to a color. Examples for the color red: red, #ff0000, rgb(255,0,0)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="code" type="EnumerationString" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains a code that may be used to refer to this label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Contains a descriptive name for this label.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="issue">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate tracking/assignment labels</sch:title>
                    <sch:rule context="issue/tracking|issue/assignment">
                        <sch:let name="labelRef" value="for $lbl in tokenize(@labels,' ') return exists(ancestor::issues[last()]/labels/label[@code=$lbl])"/>
                        <sch:assert role="warning" test="not(@labels) or count(index-of($labelRef,false()))=0">WARNING: <sch:name/>/@labels SHOULD reference defined label codes.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="object" minOccurs="0" maxOccurs="unbounded" type="IssueObject"/>
                <xs:choice minOccurs="1" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The list of historic events in terms of comments tracking and assignments</xs:documentation>
                    </xs:annotation>
                    <xs:element name="tracking" minOccurs="1" maxOccurs="unbounded" type="IssueTracking"/>
                    <xs:element name="assignment" minOccurs="0" maxOccurs="unbounded" type="IssueAssignment"/>
                </xs:choice>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The unique id of this issue</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="IssueType" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The type of this issue</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="priority" type="IssuePriority" use="optional" default="N">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The priority level of this issue, defaults to normal</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="displayName" type="LongDescriptiveName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A short text to describe the issue (headline)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="IssueType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Kind of issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="INC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Storing</xforms:label>
                        <xforms:label xml:lang="en-US">Incident</xforms:label>
                        <xforms:label xml:lang="de-DE">Störung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Incident</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="RFC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Wijzigingsverzoek</xforms:label>
                        <xforms:label xml:lang="en-US">Change Request</xforms:label>
                        <xforms:label xml:lang="de-DE">Änderungswunsch</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Change Request</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="FUT">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Voor de toekomst</xforms:label>
                        <xforms:label xml:lang="en-US">For future consideration</xforms:label>
                        <xforms:label xml:lang="de-DE">Zur zukünftigen Berücksichtigung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">For future consideration</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CLF">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Verduidelijking/toelichting noodzakelijk</xforms:label>
                        <xforms:label xml:lang="en-US">Request for Information/Education</xforms:label>
                        <xforms:label xml:lang="de-DE">Bitte um Information/Aufklärung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Request for Information/Education</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IssuePriority">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Priority of issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="HH">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoogste</xforms:label>
                        <xforms:label xml:lang="en-US">Highest</xforms:label>
                        <xforms:label xml:lang="de-DE">Höchste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Highest</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="H">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Hoog</xforms:label>
                        <xforms:label xml:lang="en-US">High</xforms:label>
                        <xforms:label xml:lang="de-DE">Hoch</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">High</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="N">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Normaal</xforms:label>
                        <xforms:label xml:lang="en-US">Normal</xforms:label>
                        <xforms:label xml:lang="de-DE">Normal</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Normal</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="L">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Laag</xforms:label>
                        <xforms:label xml:lang="en-US">Low</xforms:label>
                        <xforms:label xml:lang="de-DE">Niedrig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Low</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Laagst</xforms:label>
                        <xforms:label xml:lang="en-US">Lowest</xforms:label>
                        <xforms:label xml:lang="de-DE">Niedrigste</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Lowest</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="IssueObject">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The object(s) that are subject to the issue</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate issue object</sch:title>
                    <sch:rule context="issue/object">
                        <sch:assert test="@id or @name">ERROR: issue object SHALL have an id or a name.</sch:assert>
                        <sch:assert test="@id or (@name and @flexibility)">ERROR: if issue object has a name only, flexibility SHALL be stated.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The id of the object that is subject to the issue; either id or name of the object should be given</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The name of the object that is subject to the issue; either name or id of the object should be given</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="IssueObjectType" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The type of the object that is subject to the issue</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The optional effectiveDate of the object that is subject to the issue</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="IssueObjectType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The type of the object that is subject to an issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="DecorObjectType">
            <xs:enumeration value="VS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Waardelijst</xforms:label>
                        <xforms:label xml:lang="en-US">Value Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Value Set</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a value set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een value set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Value Set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataelement</xforms:label>
                        <xforms:label xml:lang="en-US">Data Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Datenelement</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a data element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een data element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Datenelement</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="TM">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template</xforms:label>
                        <xforms:label xml:lang="en-US">Template</xforms:label>
                        <xforms:label xml:lang="de-DE">Template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a template</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een template</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- KH 20140606: no longer supported 
            <xs:enumeration value="EL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template-element</xforms:label>
                        <xforms:label xml:lang="en-US">Template Element</xforms:label>
                        <xforms:label xml:lang="de-DE">Template-Element</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is an template element</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een template element</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Template-Element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            -->
            <xs:enumeration value="TR">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Transactie</xforms:label>
                        <xforms:label xml:lang="en-US">Transaction</xforms:label>
                        <xforms:label xml:lang="de-DE">Transaktion</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a transaction</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een transactie</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist eine Transaktion</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="DS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Dataset</xforms:label>
                        <xforms:label xml:lang="en-US">Data Set</xforms:label>
                        <xforms:label xml:lang="de-DE">Datensatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a data set</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een data set</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Datensatz</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Scenario</xforms:label>
                        <xforms:label xml:lang="en-US">Scenario</xforms:label>
                        <xforms:label xml:lang="de-DE">Szenario</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with issues is a scenario</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met de issues is een scenario</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt mit dem Problem ist ein Szenario</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="IS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Issue</xforms:label>
                        <xforms:label xml:lang="en-US">Issue</xforms:label>
                        <xforms:label xml:lang="de-DE">Issue</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Object with reference to another issue</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Object met een relatie naar een ander issue</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Objekt relatiert mit ein Issue</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- 2014-07-16 AH Added -->
            <xs:enumeration value="CS">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Codesysteem</xforms:label>
                        <xforms:label xml:lang="en-US">Code system</xforms:label>
                        <xforms:label xml:lang="de-DE">Codesystem</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Code system</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Codesysteem</xs:documentation>
                    <xs:documentation xml:lang="de-DE">Codesystem</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="IssueTracking">
        <xs:sequence>
            <xs:element ref="author" minOccurs="1" maxOccurs="1"/>
            <xs:element name="desc" minOccurs="1" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">What is the description or question associated with this tracking</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifies the effective date and time of the tracking.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statusCode" type="IssueStatusCodeLifeCycle" use="required"/>
        <xs:attribute name="labels" type="set_ShortString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">References one or multiple label codes as defined in issues/labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="IssueAssignment" mixed="true">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The assignment of an issue to a person or group</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element ref="author" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The id of the author of this assignment</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">What is the description or question associated with this assignment</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="to" type="Oid" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifier of the person or group where this issue has been assigned to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortDescriptiveName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Name / label of the person or group where this issue has been assigned to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Identifies the effective date and time of the assignment of the issue.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="labels" type="set_ShortString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">References one or multiple label codes as defined in issues/labels</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="IssueStatusCodeLifeCycle">
        <!-- 
            (start) - > new
            a new issue has been created, not yet finished
            
            new - > open
            a new issue has been opened, ready for action
            
            open - > inprogress
            the work on this issue is in progress
            
            open/inprogress - > feedback - > inprogress
            if further information or feedback on an issue is needed
            once the information is available the status can get back to inprogress
            
            open/inprogress - > rejected (end)
            an issue has been found to be rejected no further action is taken on the issue
            
            open/inprogress - > deferred - > inprogress
            open/inprogress - > deferred - > closed (end)
            an issue has been found to be deferred for future action and
            - further action is taken on the issue later
            - the issue is closed later
            
            open/inprogress - > referred (end)
            an issue has been found to be referred to other entities to take action on the issue
            
            cancelled
            at any time an issue may be cancelled (end)
            
            resolved
            an open/closed issue may proceed to resolved at any time
            
            the often found status "assigned" is detectable (if there is an assignee), not a status
            
        -->
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Life cycle of the status code of an issue</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="new">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Nieuw</xforms:label>
                        <xforms:label xml:lang="en-US">New</xforms:label>
                        <xforms:label xml:lang="de-DE">Neu</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue just created. It is new and will soon become a draft/open/finalized issue. Beyond the author, nobody should look at this issue unless it's
                        status code is open or beyond.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="open">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Open</xforms:label>
                        <xforms:label xml:lang="en-US">Open</xforms:label>
                        <xforms:label xml:lang="de-DE">Offen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is open, ready for actions to take on, also open for comments</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="inprogress">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">In behandeling</xforms:label>
                        <xforms:label xml:lang="en-US">In Progress</xforms:label>
                        <xforms:label xml:lang="de-DE">In Bearbeitung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is in progress</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="feedback">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Feedback nodig</xforms:label>
                        <xforms:label xml:lang="en-US">Feedback needed</xforms:label>
                        <xforms:label xml:lang="de-DE">Feedback nötig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is in progress but needs feedback from others</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="closed">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Gesloten</xforms:label>
                        <xforms:label xml:lang="en-US">Closed</xforms:label>
                        <xforms:label xml:lang="de-DE">Geschlossen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is closed including an solution</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="rejected">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgewezen</xforms:label>
                        <xforms:label xml:lang="en-US">Rejected</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgewiesen</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is rejected</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="deferred">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Uitgesteld</xforms:label>
                        <xforms:label xml:lang="en-US">Deferred</xforms:label>
                        <xforms:label xml:lang="de-DE">Zurückgestellt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is deferred</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cancelled">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Geannuleerd</xforms:label>
                        <xforms:label xml:lang="en-US">Cancelled</xforms:label>
                        <xforms:label xml:lang="de-DE">Annuliert</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Issue is cancelled</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="templateId">
        <xs:complexType>
            <xs:attribute name="root" type="Oid"/>
            <xs:attribute name="extension" type="EnumerationString"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="NullFlavorPattern">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Null Flavor</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="nullFlavor">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Null Flavor</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="VocabType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Vocab Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="L">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">L Leaf; a term that has no children in the specialization hierarchy, and is selectable, and therefore deemed to be a leaf.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="A">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A Abstract; a term that has children in the specialization hierarchy, but is not, itself, selectable and therefore deemed
                        abstract.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="S">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">S Specializable; a term that has children in the specialization hierarchy, and is also selectable and therefore deemed
                        specializable.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="D">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">D Deprecated; a term that should not be used any longer</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="ConformanceType">
        <xs:annotation>
            <xs:appinfo>
                <xforms:label xml:lang="nl-NL"/>
                <xforms:label xml:lang="en-US"/>
                <xforms:label xml:lang="de-DE"/>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Conformance Type</xs:documentation>
        </xs:annotation>
        <xs:restriction base="EnumerationToken">
            <xs:enumeration value="R">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Verplicht</xforms:label>
                        <xforms:label xml:lang="en-US">Required</xforms:label>
                        <xforms:label xml:lang="de-DE">Required</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">R required</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="C">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Conditioneel</xforms:label>
                        <xforms:label xml:lang="en-US">Conditional</xforms:label>
                        <xforms:label xml:lang="de-DE">Conditional</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">C conditional</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="NP">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Niet aanwezig</xforms:label>
                        <xforms:label xml:lang="en-US">Not present</xforms:label>
                        <xforms:label xml:lang="de-DE">Nicht erlaubt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">NP not present</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="OidOrNullFlavor">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Allows both OIDs for codesystems or special 'nullFlavor'</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="Oid NullFlavorPattern"/>
    </xs:simpleType>
    <xs:element name="terminology">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="terminologyAssociation" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="codeSystem" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="valueSet" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
    <xs:element name="terminologyAssociation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">terminologyAssociation links a concept to a code or a concept list to a value set</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate terminologyAssociation</sch:title>
                        <sch:rule context="terminologyAssociation[not(@expirationDate)]">
                            <sch:let name="projectId" value="(//project/@id)[1]"/>
                            <sch:let name="conceptId" value="@conceptId"/>
                            <sch:let name="valuesetRef" value="@valueSet"/>
                            <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max(//terminology/valueSet[@id=$valuesetRef or @name=$valuesetRef]/xs:dateTime(@effectiveDate)))"/>
                            <!-- In inheritance situations from another project, there is no conceptList in this project, so skip check if conceptList id is not from this project -->
                            <sch:assert role="warning" test="not(@valueSet) or //datasets/dataset//conceptList[@id=$conceptId] or not(starts-with($conceptId,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' SHOULD point to an existing conceptList</sch:assert>
                            <sch:assert role="warning" test="not(@code) or //datasets/dataset//concept[@id=$conceptId] or not(starts-with($conceptId,concat($projectId,'.')))"
                                >WARNING: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' SHOULD point to an existing concept or concept within a conceptList</sch:assert>
                            <sch:assert test="not(@valueSet) or //terminology/valueSet[(@id,@ref,@name)=$valuesetRef][@ref or @effectiveDate=$flexibility]">ERROR: <sch:name/>/@conceptId='<sch:value-of select="$conceptId"/>' MUST point to an existing valueSet '<sch:value-of select="$valuesetRef"/>' and if applicable with the correct @flexibility</sch:assert>
                            <sch:assert test="@code or @valueSet">ERROR: terminologyAssociation object SHALL have a @code or a @valueSet</sch:assert>
                            <sch:assert test="not(@code and @valueSet)">ERROR: terminologyAssociation object SHALL have a @code or a @valueSet but not both</sch:assert>
                            <sch:assert test="not(@code and @flexibility)">ERROR: if terminologyAssociation object has a @code it SHALL NOT have @flexibility</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <!--<xs:attribute name="id" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">each assignment SHOULD have a project unique id so you can attach issues, manage the status machine, change with precision, and potentially delete</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
            <!-- concept id where this assocication is associated with, applies always to all concepts with that id, regardless of its effectiveDate or statusCode -->
            <xs:attribute name="conceptId" use="required" type="Oid"/>

            <!-- a coded concept -->
            <xs:attribute name="code" use="optional" type="EnumerationString"/>
            <xs:attribute name="codeSystem" use="optional" type="OidOrNullFlavor"/>
            <!-- human readable things for codes -->
            <xs:attribute name="codeSystemName" use="optional" type="NonEmptyString"/>
            <xs:attribute ref="displayName" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A displayname for the code, only for human readablility here</xs:documentation>
                </xs:annotation>
            </xs:attribute>

            <!-- a value set and flexibility -->
            <xs:attribute name="valueSet" use="optional" type="NonEmptyString"/>
            <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility"/>

            <!-- version handling -->
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <!-- removed after talks with users: not relevant for now and a can of worms should want it -->
            <!--<xs:attribute name="statusCode" type="ReleaseStatusCodeLifeCycle" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">manages the status of the association itself</xs:documentation>
                </xs:annotation>
            </xs:attribute>-->
        </xs:complexType>
    </xs:element>
    <xs:element name="valueSet">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Value Set. A DECOR valueSet can take different forms. It may be a simple value set reference (@ref) to a value set from a repository without any contents, id, effectiveDate or statusCode, but with a name and a displayName. The other option is a valueSet with contents, id, effectiveDate, statusCode, name and displayName.</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate value set object</sch:title>
                    <sch:rule context="valueSet">
                        <sch:assert test="@id or @ref">ERROR: Value set object SHALL have an @id or a @ref</sch:assert>
                        <sch:assert test="not(@id and @ref)">ERROR: Value set object SHALL have an @id or a @ref but not both</sch:assert>
                        <sch:assert test="@ref or (@id and (conceptList/(concept|include[not(string(@exception)='true')]) or completeCodeSystem))">ERROR: Value set object with an @id SHALL have conceptList with concepts or completeCodeSystem</sch:assert>
                        <sch:assert test="not(@ref and (@*[not(name()=('ref','name','displayName'))] or conceptList or completeCodeSystem))">ERROR: Value set object with a @ref SHALL NOT have other attributes than @name or @displayName or have a conceptList or completeCodeSystem</sch:assert>
                        <!--<sch:assert test="not(completeCodeSystem and conceptList/(concept|include[not(string(@exception)='true')]))">ERROR: Value set MUST NOT reference codeSystems AND concepts.</sch:assert>-->
                        <sch:assert test="(@id and @effectiveDate) or @ref">ERROR: Value set object with an @id SHALL have an @effectiveDate</sch:assert>
                    </sch:rule>
                    <sch:rule context="valueSet/conceptList/exception">
                        <sch:let name="theCode" value="@code"/>
                        <sch:let name="theCodeSystem" value="@codeSystem"/>
                        <sch:assert test="not(preceding-sibling::exception[@code=$theCode][@codeSystem=$theCodeSystem])">ERROR: Value Set exception SHALL be unique within the same value set</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                <!-- 
                    there may be one publishing and one or more endorsing authorities
                    not used by DECOR yet
                -->
                <xs:element name="publishingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The authoritative body who has reviewed the Value set for (clinical) accuracy and relevance, 
                            and authorized it for publication. Registries may require this element to be valued</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="endorsingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A list of bodies who have reviewed the Value set for (clinical) accuracy and relevance, and endorsed it for use</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- FHIR Value Set DSTUr1 0.8 compatibility -->
                <xs:element name="copyright" type="NonEmptyString" minOccurs="0" maxOccurs="1">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A copyright statement relating to the value set and/or its contents. 
                            Comment: Frequently, the copyright differs between the value set, and codes that are included. The copyright 
                            statement should clearly differentiate between these when required.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <!-- 
                    there may be 0..* value set revision history discriptions
                    not used by DECOR yet
                -->
                <xs:element name="revisionHistory" type="ObjectHistory" minOccurs="0" maxOccurs="0">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">The free text description describing the changes in this version of the Value set
                            as compared to the previous version. Since Value set versions are built off of previous versions, the net effect 
                            of this field is to function as a comprehensive historical reference of the Value set.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="completeCodeSystem" type="CodeSystemReference" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="conceptList" type="ValueSetConceptList" minOccurs="0" maxOccurs="1"/>
            </xs:sequence>
            <xs:attribute name="id" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Defines the globally unique identifier for this value set and may be used to reference it. Value sets SHOULD carry either @id or @ref</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" type="Oid" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Reference to a valueSet/@id. Value sets SHALL carry either @id or @ref</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="name" use="required" type="BasicId"/>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            
            <!-- if @ref, flexibility -->
            <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="CodeSystemReference">
        <xs:attribute name="codeSystem" type="Oid" use="required"/>
        <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Display name for the code system as it is known in your context. This may or may not be the official name for the code system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystemVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Version string for the code system. This is only relevant for code systems with incompatible versions. If specified, than your instances will need to carry this information exactly as-is.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility"/>
    </xs:complexType>
    <xs:complexType name="ValueSetConceptList">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="concept" type="ValueSetConcept"/>
                <xs:element name="include" type="ValueSetRef"/>
            </xs:choice>
            <xs:element name="exception" type="ValueSetConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:complexType name="ValueSetConcept">
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">You may add a description for convenience, but should note that most of the time the description here overlaps with the designation/description of the coded concept</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="code" type="EnumerationString" use="required"/>
        <xs:attribute name="codeSystem" type="OidOrNullFlavor" use="required"/>
        <xs:attribute name="codeSystemName" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Display name for the code system as it is known in your context. This may or may not be the official name for the code system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="codeSystemVersion" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Version string for the code system. This is only relevant for code systems with incompatible versions. If specified, than your instances will need to carry this information exactly as-is.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute ref="displayName" use="required"/>
        <xs:attribute name="level" type="xs:integer" use="required"/>
        <xs:attribute name="type" type="VocabType" use="required"/>
    </xs:complexType>
    <xs:complexType name="ValueSetRef">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Include of another valueSet, typically from a repository, but potentially within the same DECOR definition.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">You may add a description for convenience, but should note that most of the time the description here overlaps with the description of the referenced value set</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="ref" use="required" type="Oid">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a valueSet/@id.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a valueSet/@effectiveDate. Default is 'dynamic' which means 'latest available version'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="exception" use="optional" type="xs:boolean" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Indicates whether the valueSet contents should be treated as exceptions. Default is 'false' meaning that the contents are included as concepts.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:element name="codeSystem">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Code system</xs:documentation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate code system object</sch:title>
                    <sch:rule context="codeSystem">
                        <sch:assert test="@id or @ref">ERROR: Code system object SHALL have an @id or a @ref.</sch:assert>
                        <sch:assert test="not(@id and @ref)">ERROR: Code system object SHALL have an @id or a @ref but not both</sch:assert>
                        <sch:assert test="@ref or (@id and conceptList)">ERROR: A code system object with an @id SHALL have a conceptList</sch:assert>
                        <sch:assert test="@ref or (@id and @effectiveDate)">ERROR: A code system object with an @id SHALL have an @effectiveDate</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A description that describes the Code System</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="conceptList" type="CodeSystemConceptList" minOccurs="0" maxOccurs="1"/>
            </xs:sequence>
            <xs:attribute name="id" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A version identifier that uniquely identifies each version of a Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="ref" use="optional" type="Oid">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A reference to a version identifier of a Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="name" use="required" type="BasicId"/>
            <xs:attribute ref="displayName" use="required"/>
            <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
            <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>
            <!-- if @ref, flexibility -->
            <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="CodeSystemConceptList">
        <xs:sequence>
            <xs:element ref="codedConcept" minOccurs="1" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    <xs:element name="codedConcept">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="designation" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                        <xs:documentation xml:lang="en-US">A language symbol for the concept that is intended to convey the concept meaning to a human being. It may contain multiple designations per
                            language to expres preferences, synonyms etc. For example, in SNOMED CT, the concept of "fever" has the fully specified name of "fever (finding)", a preferred name of
                            "fever", and synonyms of "febrile" and "pyrexia". These are all designations in English for the concept of "fever".</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="code" type="EnumerationString" use="required">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">An identifier that uniquely names the class or "concept" within the context of the defining Code System</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="statusCode" type="NonEmptyString" use="optional" default="active">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Status of the "concept", in this context only "active" concepts are listed</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="level" type="xs:integer" use="required"/>
            <xs:attribute name="type" type="VocabType" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="designation">
        <xs:complexType>
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A description for the designation</xs:documentation>
                <xs:appinfo>
                    <sch:pattern>
                        <sch:title>Validate FreeFormMarkupWithLanguage designation</sch:title>
                        <sch:rule context="designation[not(ancestor::example)]">
                            <sch:assert role="error" test="not(preceding-sibling::*[name()=name(current())][@language=current()/@language][@type='preferred' and current()/@type='preferred'])">ERROR: Each repetition of <sch:name path=".."/>/<sch:name/> with language SHALL be a different language, or only one SHALL be marked 'preferred'</sch:assert>
                            <sch:assert role="warning" test="@language">WARNING: Each repetition of <sch:name path=".."/>/<sch:name/> SHOULD be qualified with @language</sch:assert>
                        </sch:rule>
                    </sch:pattern>
                </xs:appinfo>
            </xs:annotation>
            <xs:complexContent>
                <xs:extension base="FreeFormMarkupWithLanguage">
                    <xs:attribute name="type" type="DesignationType" use="optional">
                        <xs:annotation>
                            <xs:documentation xml:lang="en-US">Type of designation (for that langauge), preferred, synonym, abbreviation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute ref="displayName" use="required">
                        <xs:annotation>
                            <xs:documentation xml:lang="en-US">A short description string for the designation</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DesignationType">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="preferred">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">preferred</xforms:label>
                        <xforms:label xml:lang="nl-NL">preferent</xforms:label>
                        <xforms:label xml:lang="de-DE">bevorzugt</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">preferred</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="synonym">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">synonym</xforms:label>
                        <xforms:label xml:lang="nl-NL">synoniem</xforms:label>
                        <xforms:label xml:lang="de-DE">synonym</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">synonym</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="abbreviation">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="en-US">abbreviation</xforms:label>
                        <xforms:label xml:lang="nl-NL">afkorting</xforms:label>
                        <xforms:label xml:lang="de-DE">Abkürzung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">abbreviation</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="rules">
        <xs:complexType>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="templateAssociation" type="TemplateAssociationDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="template" type="TemplateDefinition" minOccurs="1" maxOccurs="unbounded"/>
            </xs:choice>
        </xs:complexType>
        <!-- Cannot have two templates carrying the same id and effectiveDate -->
        <xs:unique name="templateuniquekey">
            <xs:selector xpath="./template"/>
            <xs:field xpath="@id"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
        <!-- Cannot have two templateAssociations for the same template (based on id and effectiveDate) -->
        <xs:unique name="templateAssociationuniquekey">
            <xs:selector xpath="./templateAssociation"/>
            <xs:field xpath="@templateId"/>
            <xs:field xpath="@effectiveDate"/>
        </xs:unique>
    </xs:element>
    <xs:complexType name="TemplateAssociationDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Template Association Definition</sch:title>
                    <!-- <templateAssociation templateId="2.16.840.1.113883.2.4.6.10.100.13" effectiveDate="2012-05-09T00:00:00"> -->
                    <sch:rule context="templateAssociation">
                        <sch:let name="templateId" value="@templateId"/>
                        <sch:let name="effectiveDate" value="@effectiveDate"/>
                        <sch:assert test="//rules/template[@id=$templateId][@effectiveDate=$effectiveDate]"
                            >ERROR: A template association SHALL be bound with a template with the same id and effective date</sch:assert>
                        
                        <sch:assert test="count(../templateAssociation[@templateId=$templateId][@effectiveDate=$effectiveDate])&lt;=1"
                            >ERROR: There SHALL be 0..1 template association per template (<sch:value-of select="$templateId"/> - <sch:value-of select="$effectiveDate"/>)</sch:assert>
                        <!-- 2DO a template has 0..1 templateAssociation -->
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="concept" type="TemplateAssociationConcept" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="templateId" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the template/@id where this template association is referring to</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to the template/@effectiveDate where this template association is referring to (should 
                    actually be named templateEffectiveDate according to the other attribute @templateId</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="TemplateAssociationConcept">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Template Association Concept</sch:title>
                    <!-- <concept ref="2.16.840.1.113883.2.4.3.11.60.100.2.4.472" effectiveDate="2012-05-20T14:12:37" elementId="2.16.840.1.113883.2.4.3.11.60.100.9.13.2"/> -->
                    <sch:rule context="templateAssociation/concept">
                        <sch:let name="templateId" value="parent::templateAssociation/@templateId"/>
                        <sch:let name="templateEffectiveDate" value="parent::templateAssociation/@effectiveDate"/>
                        <sch:let name="conceptId" value="@ref"/>
                        <sch:let name="conceptEffectiveDate" value="@effectiveDate"/>
                        <sch:let name="datasetConcept" value="//datasets//concept[@id=$conceptId][not(@effectiveDate) or @effectiveDate=$conceptEffectiveDate][not(ancestor::history)]"/>
                        <sch:let name="elementId" value="@elementId"/>
                        <sch:let name="templateElement" value="ancestor::rules/template[@id=$templateId][@effectiveDate=$templateEffectiveDate]//*[@id=$elementId]"/>
                        <sch:assert test="$datasetConcept"
                            >ERROR: A template association concept SHALL be bound to a concept with same id and (if indicated) effective date</sch:assert>
                        <sch:assert role="error" test="$templateElement"
                            >ERROR: A template association concept SHALL be bound to an element with the indicated id '<sch:value-of select="$elementId"/>' in the indicated template with the same id and effective date</sch:assert>
                        
                        <sch:let name="termAssocsConcept" value="//terminologyAssociation[@conceptId=($datasetConcept/@id|$datasetConcept/inherit/@ref)]"/>
                        <sch:let name="tempElement" value="$templateElement/../element[@name='hl7:code']"/>
                        <sch:assert role="warning" test="not($datasetConcept) or not($tempElement) or not($termAssocsConcept) or $termAssocsConcept[concat(@code,'#',@codeSystem)=$tempElement/vocabulary/concat(@code,'#',@codeSystem)]"
                            >WARNING: Element '<sch:value-of select="$tempElement/@name"/>' (id=<sch:value-of select="$elementId"/>) is not bound to the same code as the dataset concept<sch:value-of select="concat(' ''',$datasetConcept/name[1],'''')"/>. 
                            Found "code='<sch:value-of select="$tempElement/vocabulary/@code"/>' codeSystem='<sch:value-of select="$tempElement/vocabulary/@codeSystem"/>'", expected "code='<sch:value-of select="$termAssocsConcept/@code"/>' codeSystem='<sch:value-of select="$termAssocsConcept/@codeSystem"/>'"</sch:assert>
                        
                        <!--<sch:let name="conceptIsItem" value="if ($datasetConcept) then exists(//datasets//concept[@id=$conceptId][not(@effectiveDate) or @effectiveDate=$conceptEffectiveDate][not(ancestor::history)][@type='item' or not(concept)][not(valueDomain/@type='complex')]) else (false())"/>-->
                        <!--<sch:let name="elementHasDatatype" value="if ($templateElement) then ancestor::rules/template[@id=$templateId][@effectiveDate=$templateEffectiveDate]//*[@id=$elementId][@datatype] else()"/>-->
                        <!--<sch:assert role="warning" test="not($templateElement) or not($conceptIsItem) or $elementHasDatatype"
                            >WARNING: Concept item <sch:value-of select="$conceptId"/> (<sch:value-of select="$conceptEffectiveDate"/>) SHOULD probably be bound to an element with a datatype</sch:assert>-->
                        
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:attribute name="ref" use="required" type="Oid">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a concept/@id that is not in history or in a concept list</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required"/>
        <xs:attribute name="elementId" type="Oid" use="required"/>
    </xs:complexType>
    <xs:complexType name="TemplateDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Rules/Templates</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]">
                        <sch:let name="id" value="@id"/>
                        
                        <sch:assert test="@id or @ref">ERROR: Template object SHALL have an @id or a @ref</sch:assert>
                        <sch:assert test="not(@id and @ref)">ERROR: Template object SHALL have an @id or a @ref but not both</sch:assert>
                        
                        <sch:assert test="(@id and @effectiveDate) or @ref">ERROR: Template object with an @id SHALL have an @effectiveDate</sch:assert>
                        
                        <sch:assert test="not(context[@id='*']) or element[matches(@name,'^([^:]+:)?templateId(\[.*)?$')]/attribute[@root=$id or (@name='root' and @value=$id)]"
                            >ERROR: if context of template is * an element named templateId (e.g. hl7:templateId) shall be defined with an attribute @root id (or name value pair) of that template</sch:assert>
                        <sch:assert test="not(context[@id='**']) or */element[matches(@name,'^([^:]+:)?templateId(\[.*)?$')]/attribute[@root=$id or (@name='root' and @value=$id)]"
                            >ERROR: if context of template is ** an element named templateId (e.g. hl7:templateId) shall be defined with an attribute @root id (or name value pair) of that template</sch:assert>
                        
                        <sch:assert test="not(@id and (@*[name()=('ref','flexibility')]))"
                            >ERROR: template with a @id SHALL NOT have attributes @ref or @flexibility</sch:assert>
                        <sch:assert test="not(@ref and (@*[not(name()=('ref','name','displayName'))] or *[not(name()='desc')]))"
                            >ERROR: template with a @ref SHALL NOT have other attributes than @name or @displayName and MAY have description</sch:assert>
                        
                        <sch:assert role="error" test="@ref or (@effectiveDate and @statusCode)"
                            >ERROR: template SHALL have @ref or (@effectiveDate and @statusCode)</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of template -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
             <!-- the type(s) etc of the template, for later use -->
            <xs:element name="classification" type="TemplateProperties" minOccurs="0" maxOccurs="unbounded"/>
            <!-- relationships of this template -->
            <xs:element name="relationship" type="TemplateRelationships" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:appinfo>
                        <sch:pattern>
                        <sch:title>Validate Template Relationship</sch:title>
                            <sch:rule context="template/relationship">
                                <sch:assert role="error" test="(@template or @model) and not(@template and @model)">ERROR: must have either <sch:name/>/@template or <sch:name/>/@model, and not both</sch:assert>
                            </sch:rule>
                        </sch:pattern>
                    </xs:appinfo>
                </xs:annotation>
            </xs:element>
            <!-- context of template
                either
                <context id="*"/> for an element templateId context
                or <context path="//"/> for a specific context path
            -->
            <xs:element ref="context" minOccurs="0" maxOccurs="1"/>
            <!-- item reference and description(s), inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <!-- examples may be given -->
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                there maybe 0..n inherit definitions before others in a template (indicating parent / sibling templates)
                not used by DECOR yet
            -->
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="0"/>
            <!-- 
                there may be one publishing and one or more endorsing authorities
                not used by DECOR yet
            -->
            <xs:element name="publishingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The authoritative body who has reviewed the Template for (clinical) accuracy and relevance, 
                        and authorized it for publication. Registries may require this element to be valued</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="endorsingAuthority" type="AuthorityType" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">A list of bodies who have reviewed the Template for (clinical) accuracy and relevance, 
                        and endorsed it for use</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- 
                there may be 0..* template revision history discriptions
                not used by DECOR yet
            -->
            <xs:element name="revisionHistory" type="ObjectHistory" minOccurs="0" maxOccurs="0">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">The free text description describing the changes in this version of the Template as compared to the previous version. 
                        Since Template versions are built off of previous versions, the net effect of this field is to function as a
                        comprehensive historical reference of the Template.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <!-- 
                the design body: elements, attributes, choices or includes
            -->
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="attribute" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="choice" type="ChoiceDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element name="include" type="IncludeDefinition" minOccurs="1" maxOccurs="unbounded"/>
                <xs:element ref="let" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="assert" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="report" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defineVariable" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of element (validation done by embedded schematron) -->
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The identifying OID of the template</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id. Templates SHALL carry either @id or @ref</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="ShortFormalName" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The identifying name of the template</xs:documentation>
            </xs:annotation>
        </xs:attribute>

        <!-- attributes of template (validation done by embedded schematron) -->
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="TemplateStatusCodeLifeCycle" use="optional"/>
        <xs:attribute ref="displayName" use="optional"/>
        <xs:attribute name="isClosed" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Whether the template is open (other elements than specified allowed) or closed (no other elements than specified allowed)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="AuthorityType" mixed="true">
        <xs:sequence>
            <xs:element ref="addrLine" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="id" type="Oid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Id of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="name" type="NonEmptyString" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Name of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <!--<xs:attribute name="email" type="EmailType" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Email address of the authority/organisation/person</xs:documentation>
            </xs:annotation>
        </xs:attribute>-->
    </xs:complexType>
    <xs:complexType name="ObjectHistory">
        <xs:sequence>
            <xs:element name="desc" type="FreeFormMarkupWithLanguage" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="date" type="TimeStampNoTimezone"/>
        <xs:attribute name="by" type="NonEmptyString"/>
    </xs:complexType>
    <xs:complexType name="TemplateProperties">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The classification of the template</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="tag" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">In addition, tag elements could be incorporated to specifiy any number of tags for search purposes</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="property" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">In addition, property elements could be incorporated to specifiy any number of properties not part of the standard metadata, e.g. for operationalization instructions</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="type" type="TemplateTypes" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The @type of the template, at this point in time something like "cdaentrylevel", "cdasectionlevel", "cdaheaderlevel", "cdadocumentlevel", "messagelevel",
                    "clinicalstatementlevel", "datatypelevel" etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="format" type="TemplateFormats" use="optional" default="hl7v3xml1">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">As of now only a few formats are supported, e.g. "HL7 V3 XML ITS 1" = hl7v3xml1</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="TemplateTypes">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="cdadocumentlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA document level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA document level template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA document level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA document level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdaheaderlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA header level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA header level template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA header level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA header level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdasectionlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA section level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA section level template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA section level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA section level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="cdaentrylevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">CDA entry level template</xforms:label>
                        <xforms:label xml:lang="en-US">CDA entry level template</xforms:label>
                        <xforms:label xml:lang="de-DE">CDA entry level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">CDA entry level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="messagelevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2/v3 message level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2/V3 message level template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2/V3 message level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 or V3 message level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="segmentlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2 segment level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2 segment level template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2 segment level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 segment level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="clinicalstatementlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 clinical statement level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 clinical statement level template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 clinical statement level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 clinical statement level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="controlactlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Control Act level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Control Act level template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Control Act level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Control Act level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="payloadlevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v3 Payload level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V3 Payload level template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V3 Payload level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V3 Payload level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="datatypelevel">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">HL7v2/v3 datatype level template</xforms:label>
                        <xforms:label xml:lang="en-US">HL7 V2/V3 data type level template</xforms:label>
                        <xforms:label xml:lang="de-DE">HL7 V2/V3 data type level template</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">HL7 V2 or V3 data type level template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="notype">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Templatetype niet gespecificeerd</xforms:label>
                        <xforms:label xml:lang="en-US">Template type not specified</xforms:label>
                        <xforms:label xml:lang="de-DE">Template type not specified</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template type not specified</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="TemplateRelationships">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">The relationships of the template regarding other templates or model artifacts</xs:documentation>
        </xs:annotation>
        <xs:attribute name="type" type="RelationshipTypes" use="required">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">The @type of the relationship of the template, at this point in time something like "SPEC", "GEN", "EQUIV", "VERSION", etc.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="template" type="BasicIdOrOid" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A reference by name or id to a template identifer, used for template-template relationships</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="model" type="NonEmptyString" use="optional">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">A reference to a model artifact identifier or description specifying from what this template is derived from or based on, e.g. an HL7 R-MIM, a DCM,
                    used for template-model relationships</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Static or dynamic binding for the template or model that is referred.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:simpleType name="RelationshipTypes">
        <xs:restriction base="xs:NMTOKEN">
            <!-- Template-template relationships -->
            <xs:enumeration value="REPL">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Vervanging</xforms:label>
                        <xforms:label xml:lang="en-US">Replacement</xforms:label>
                        <xforms:label xml:lang="de-DE">Ersatz</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template replaces @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SPEC">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Specialisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Specialization</xforms:label>
                        <xforms:label xml:lang="de-DE">Spezialisierung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template specializes @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="GEN">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Generalisatie</xforms:label>
                        <xforms:label xml:lang="en-US">Generalization</xforms:label>
                        <xforms:label xml:lang="de-DE">Generalisierung</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template generalizes @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="COPY">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Kopie</xforms:label>
                        <xforms:label xml:lang="en-US">Copy</xforms:label>
                        <xforms:label xml:lang="de-DE">Kopie</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is a design copy of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ADAPT">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Adaptatie</xforms:label>
                        <xforms:label xml:lang="en-US">Adaptation</xforms:label>
                        <xforms:label xml:lang="de-DE">Adaptation</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is an adaptation of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EQUIV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Equivalent</xforms:label>
                        <xforms:label xml:lang="en-US">Equivalent</xforms:label>
                        <xforms:label xml:lang="de-DE">Equivalent</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is equivalent to @template regarding design</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="VERSION">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Versie</xforms:label>
                        <xforms:label xml:lang="en-US">Versie</xforms:label>
                        <xforms:label xml:lang="de-DE">Version</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is a version of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="BACKWD">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Backward compatible</xforms:label>
                        <xforms:label xml:lang="en-US">Backward Compatible</xforms:label>
                        <xforms:label xml:lang="de-DE">Rückwärtskompatibel</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">This template is backward compatible of @template</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!-- Template-model relationships -->
            <xs:enumeration value="DRIV">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Afgeleide</xforms:label>
                        <xforms:label xml:lang="en-US">Derived</xforms:label>
                        <xforms:label xml:lang="de-DE">Abgeleitet</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">For future use: This template is derived from model or other artifact expressed or specified in the @template attribute</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="TemplateFormats">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="hl7v3xml1">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v3 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V3 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V3 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V3 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <!--<xs:enumeration value="hl7v2.3.1xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.3.1 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.3.1 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.3.1 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.3.1 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="hl7v2.4xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.4 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.4 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.4 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.4 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>-->
            <xs:enumeration value="hl7v2.5xml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format HL7v2.5 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="en-US">Template format HL7 V2.5 XML ITS 1</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format HL7 V2.5 XML ITS 1</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format HL7 V2.5 XML ITS 1</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="fhirxml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format FHIR XML</xforms:label>
                        <xforms:label xml:lang="en-US">Template format FHIR XML</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format FHIR XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format FHIR XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="vmrxml">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Template format vMR CDS XML</xforms:label>
                        <xforms:label xml:lang="en-US">Template format vMR CDS XML</xforms:label>
                        <xforms:label xml:lang="de-DE">Template format vMR CDS XML</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Template format vMR CDS XML</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="RuleDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Rules/Templates</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element">
                        <sch:assert test="not(@isMandatory='true' and @minimumMultiplicity=0)">ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        
                        <sch:assert role="error" test="not(@isMandatory='true' and attribute[(@nullFlavor or @name='nullFlavor')][not(@prohibited='true')])"
                            >ERROR <sch:name/> defines a @nullFlavor, but element has @isMandatory='true'</sch:assert>
                        
                        <sch:assert test="not(references)">ERROR: The &lt;references/&gt; element SHALL NOT be used any more. Use rules/templateAssociation instead.</sch:assert>
                        
                        <sch:let name="ref" value="@contains"/>
                        <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max(//rules/template[@id=$ref or @name=$ref]/xs:dateTime(@effectiveDate)))"/>
                        <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                        <sch:assert test="not(@contains) or (//rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility] and string-length(xs:string($flexibility))&gt;0)">ERROR: <sch:name/>/@contains='<sch:value-of select="$ref"/>' MUST point to an existing template with flexibility '<sch:value-of select="$flextext"/>'</sch:assert>
                        <!--sch:assert role="warning" test="not(@contains and //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][not(context)])"
                            >WARNING: <sch:name/>/@contains='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template without context. Best practise is usually to use include instead of element/@contains</sch:assert-->
                        <sch:assert role="warning" test="not(@contains and //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][context[@path]]) or parent::choice">WARNING: <sch:name/>/@contains='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@path. Best practise is to call this type of template only from a transaction. When called from another template, this context path is overridden by the context of the calling template</sch:assert>
                        
                        <!--
                        <sch:assert test="not (@minimumMultiplicity and @isMandatory) or (@isMandatory='true' and @minimumMultiplicity>0)">ERROR: if isMandatory=true, minimumMultiplicity shall be
                            greater than 0</sch:assert>
                        <sch:assert test="not(@name and @include) and not(@name and @contains)">An element may contain @name or @name/@contains or @include</sch:assert>
                        -->
                        
                        <!-- Background: the check on valueSet does not consider code(System)s in the other vocabulary element and vice versa. So there will be errors about a valid codeSystem or a valid code regardless -->
                        <!--<sch:assert role="warning" test="not(vocabulary[@valueSet] and vocabulary[@code or @codeSystem])">WARNING: combining vocabulary definitions based on a valueSet and based on a @code and/or @codeSystem is currently not supported in the schematron engine. Consider creating a valueSet that supports the specified combination.</sch:assert>-->
                        
                        <sch:let name="datatypeFile" value="if (ancestor::template/classification/@format[not(.='hl7v3xml1')]) then concat('DECOR-supported-datatypes-',ancestor::template/classification/@format[not(.='hl7v3xml1')][1],'.xml') else 'DECOR-supported-datatypes.xml'"/>
                        <!--<sch:let name="dtNsURI" value="if (contains(@datatype,':')) then namespace-uri-for-prefix(substring-before(@datatype,':')) else ('urn:hl7-org:v3')"/>-->
                        <sch:let name="dtName" value="if (contains(@datatype,':')) then substring-after(@datatype,':') else (@datatype)"/>
                        <sch:assert role="error" test="not(doc-available($datatypeFile)) or not(@datatype) or $dtName=doc($datatypeFile)//dataType//@name"
                            >ERROR: the element/@datatype '<sch:value-of select="@datatype"/>' SHALL be a supported datatype (reference file: <sch:value-of select="$datatypeFile"/>)</sch:assert>
                        
                        <sch:let name="elmpfx" value="substring-before(@name,':')"/>
                        <sch:let name="elmns" value="if ($elmpfx=('hl7','cda')) then ('urn:hl7-org:v3') else if (string-length($elmpfx)&gt;0) then (namespace-uri-for-prefix($elmpfx,/decor)) else ()"/>
                        <sch:assert role="error" test="not(@name) or $elmns"
                            >ERROR: template element/@name='<sch:value-of select="@name"/>' SHALL have a known namespace prefix ('hl7' and 'cda' are declared by default, any other SHALL be declared on the root element decor)</sch:assert>
                        
                        <sch:assert role="error" test="not(@id) or count(index-of(ancestor::template//@id,@id))=1"
                            >ERROR: template element/@id='<sch:value-of select="@id"/>' SHALL be unique within the template (version). Found <sch:value-of select="count(index-of(ancestor::template//@id,@id))"/> occurrences</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of elements -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <!-- examples may be given -->
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                there maybe 0..1 inherit definitions before others in an element (indicating parent and sibling templates)
            -->
            <xs:element name="inherit" type="InheritDefinition" minOccurs="0" maxOccurs="0"/>
            <!-- 
                there may be 0..* vocabulary and 0..* property specifications
            -->
            <xs:choice>
                <xs:element ref="vocabulary" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="property" minOccurs="0" maxOccurs="unbounded"/>
            </xs:choice>
            <!-- 
                there may be 0..* text (element content) specifications
            -->
            <xs:element name="text" type="NonEmptyString" minOccurs="0" maxOccurs="unbounded"/>

            <!-- 
                attribute(s)
            -->
            <xs:element ref="attribute" minOccurs="0" maxOccurs="unbounded"/>
            <!-- 
                choice of
                
                let
                assert 
                report
                
                defineVariable
                
                include
                
                choice
                
                or a new nested element
                
                or (non rule generating) items
                constraint
                issue
            -->
            <xs:choice maxOccurs="unbounded">
                <xs:element ref="let" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="assert" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="report" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="defineVariable" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="include" type="IncludeDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="choice" type="ChoiceDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of template (validation done by embedded schematron) -->
        <xs:attribute ref="displayName" use="optional"/>
        <xs:attributeGroup ref="VersionHandlingEffectiveDateOptional"/>
        <xs:attribute name="statusCode" type="ItemStatusCodeLifeCycle" use="optional"/>

        <!-- attributes of element (validation done by embedded schematron) -->
        <xs:attribute name="name" use="optional" type="xs:anyURI"/>

        <!-- @include is no longer supported and replaced by the include element, useWhere is not implemented yet -->
        <xs:attribute name="include" type="xs:anyURI" use="prohibited"/>
        <xs:attribute name="useWhere" type="xs:boolean" default="false" use="optional"/>

        <!-- @contains -->
        <xs:attribute name="contains" use="optional" type="xs:anyURI"/>
        <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility"/>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType" use="optional"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false" use="optional"/>

        <!-- an optional id for to be referenced by associated concepts -->
        <xs:attribute name="id" type="Oid"/>

        <!-- data type -->
        <!--<xs:attribute name="datatype" type="DatatypeName"/>-->
        <xs:attribute name="datatype" type="xs:QName"/>
        <xs:attribute name="isClosed" type="xs:boolean" use="optional" default="false">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Whether the template is open (other elements than specified allowed) or closed (no other elements than specified allowed)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
    <xs:complexType name="IncludeDefinition">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate includes</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//include">
                        <sch:assert test="not(@isMandatory='true' and @minimumMultiplicity=0)">ERROR: if isMandatory=true, minimumMultiplicity SHALL be greater than 0</sch:assert>
                        
                        <sch:let name="ref" value="@ref"/>
                        <sch:let name="flexibility" value="if (matches(@flexibility,'^\d{4}')) then (@flexibility) else (max(//rules/template[@id=$ref or @name=$ref]/xs:dateTime(@effectiveDate)))"/>
                        <sch:let name="flextext" value="if (@flexibility) then (@flexibility) else ('dynamic')"/>
                        <sch:let name="reffedTemplate" value="//rules/template[(@id|@name|@ref)=$ref][@ref or @effectiveDate=$flexibility]"/>
                        <sch:assert test="not($ref) or $reffedTemplate"
                            >ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' MUST point to an existing template with flexibility '<sch:value-of select="$flextext"/>'</sch:assert>
                        <sch:assert test="not($reffedTemplate/attribute) or (parent::element and not(preceding-sibling::element|preceding-sibling::choice))"
                            >ERROR: <sch:name/>/@ref='<sch:value-of select="$ref"/>' points to a template containing toplevel attributes, but your context is not an element</sch:assert>
                        <sch:assert role="warning" test="not(@ref and //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][context[@id]]) or parent::choice"
                            >WARNING: <sch:name/>/@ref='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@id. Best practise is usually to use element/@contains instead of include</sch:assert>
                        <sch:assert role="warning" test="not(@ref and //rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility][context[@path]])
                            ">WARNING: <sch:name/>/@ref='<sch:value-of select="$ref"/>' flexibility '<sch:value-of select="$flextext"/>' points to a template with context/@path. Best practise is to call this type of template only from a transaction. When called from another template, this context path is overridden by the context of the calling template</sch:assert>
                        <sch:let name="tcnt" value="count(//rules/template[@id=$ref or @name=$ref][@effectiveDate=$flexibility]/(element|choice|include))"/>
                        <sch:assert role="warning" test="not(@minimumMultiplicity|@maximumMultiplicity|@conformance|@isMandatory) or $tcnt&lt;=1">WARNING: you SHOULD NOT specify multiplicity, conformance or isMandatory on an include if it points to more than one element in the template it references.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of an include -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <xs:element ref="example" minOccurs="0" maxOccurs="unbounded"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>

        <!-- attributes of includes (validation done by embedded schematron) -->
        <xs:attribute name="ref" use="optional" type="xs:anyURI">
            <xs:annotation>
                <xs:documentation xml:lang="en-US">Reference to a template/@id or template/@name.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="flexibility" use="optional" type="StaticOrDynamicFlexibility"/>

        <!-- attributes of includes (validation done by embedded schematron) -->
        <xs:attribute name="scenario" type="NonEmptyString" use="prohibited"/>
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="prohibited"/>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
        <xs:attribute name="conformance" type="ConformanceType" use="optional"/>
        <xs:attribute name="isMandatory" type="xs:boolean" default="false" use="optional"/>
    </xs:complexType>
    <xs:complexType name="InheritDefinition">
        <xs:annotation>
            <xs:appinfo>Inherit an artefact (here: a concept or a template), referenced by a ref (name or id). 
                If no effectiveDate is given, flexibility DYMAIC is assumed, STATIC date otherwise.</xs:appinfo>
        </xs:annotation>
        <!-- attributes of inherit (validation done by embedded schematron) -->
        <xs:attribute name="ref" use="required" type="xs:anyURI"/>
        <!-- attributes of inherit (validation done by embedded schematron) -->
        <xs:attribute name="effectiveDate" type="TimeStampNoTimezone" use="required"/>
    </xs:complexType>
    <xs:complexType name="ChoiceDefinition">
        <xs:annotation>
            <xs:appinfo> </xs:appinfo>
        </xs:annotation>
        <xs:sequence>
            <!-- description(s) of elements -->
            <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            <!-- item label, inherited by all subsequent elements unless overridden -->
            <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="include" type="IncludeDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element name="element" type="RuleDefinition" minOccurs="0" maxOccurs="unbounded"/>
                <!-- DEPRECATED: <xs:element ref="references" minOccurs="0" maxOccurs="unbounded"/> -->
                <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:choice>
        </xs:sequence>
        <xs:attributeGroup ref="MultiplicityRangeOptional"/>
    </xs:complexType>
    <xs:element name="example">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:any minOccurs="0" maxOccurs="unbounded" namespace="##any" processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="type" type="ExampleType" use="optional" default="neutral">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Can be used to indicate that the instance fragment (example) is right (@type=valid) or wrong (@type=error); default is "neutral".</xs:documentation>
                    <xs:documentation xml:lang="nl-NL">Kan worden gebruikt om te markeren dat het instancefragment (voorbeeld) geldig is (@type=valid) of fout (@type=error); standaardwaarde is "neutral".</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="caption" type="NonEmptyString" use="optional">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Can be used to specify a caption (string) that precedes the instance fragment (example)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="ExampleType">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="error">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">ongeldig</xforms:label>
                        <xforms:label xml:lang="en-US">error</xforms:label>
                        <xforms:label xml:lang="de-DE">ungültig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate explicitly that the instance fragment (example) is in error.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het een foutief instancefragment (voorbeeld) betreft.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="valid">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">geldig</xforms:label>
                        <xforms:label xml:lang="en-US">valid</xforms:label>
                        <xforms:label xml:lang="de-DE">gültig</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate explicitly that the instance fragment (example) is valid.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het een correct instancefragment (voorbeeld) betreft.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="neutral">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">neutraal</xforms:label>
                        <xforms:label xml:lang="en-US">neutral</xforms:label>
                        <xforms:label xml:lang="de-DE">neutral</xforms:label>
                    </xs:appinfo>
                    <xs:documentation xml:lang="en-US">Used to indicate that the instance fragment (example) is not explictly stated to be right or wrong.</xs:documentation>
                <xs:documentation xml:lang="nl-NL">Om aan te geven dat het instancefragment (voorbeeld) niet expliciet geldig of ongeldig is.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <!--
        DEPRECATED: 
    <xs:element name="references">
        < ! - - references concept="2.16.840.1.113883.2.4.6.99999.90.20010" target="2.16.840.1.113883.2.4.6.99999.90.3.700" - - >
        <xs:complexType>
            <xs:attribute name="concept" type="Oid"/>
            <xs:attribute name="target" type="Oid"/>
        </xs:complexType>
    </xs:element>
    -->
    <xs:attribute name="displayName" type="NonEmptyString">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A short description string for the designation</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    
    <!-- version handling -->
    <xs:attribute name="effectiveDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the effective date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expirationDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the exiration date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="officialReleaseDate" type="TimeStampNoTimezone">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Identifies the official release date of the version of the object.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="versionLabel" type="ShortDescriptiveName">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A human readable version number or version label for convenient human rendition; not used by an application.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup name="VersionHandling">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used to define version handling attributes</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="effectiveDate" use="required"/>
        <xs:attribute ref="expirationDate" use="optional"/>
        <xs:attribute ref="officialReleaseDate" use="optional"/>
        <xs:attribute ref="versionLabel" use="optional"/>
    </xs:attributeGroup>
    <xs:attributeGroup name="VersionHandlingEffectiveDateOptional">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used to define version handling attributes, effective date is optional here</xs:documentation>
        </xs:annotation>
        <xs:attribute ref="effectiveDate" use="optional"/>
        <xs:attribute ref="expirationDate" use="optional"/>
        <xs:attribute ref="officialReleaseDate" use="optional"/>
        <xs:attribute ref="versionLabel" use="optional"/>
    </xs:attributeGroup>
    <xs:element name="let">
        <xs:complexType>
            <xs:attribute name="name" type="NonEmptyString" use="required"/>
            <xs:attribute name="value" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="assert">
        <xs:complexType mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="flag" type="NonEmptyString" use="optional"/>
            <xs:attribute name="see" type="NonEmptyString" use="optional"/>
            <xs:attribute name="role" type="AssertRole" use="required"/>
            <xs:attribute name="test" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="report">
        <xs:complexType mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:any processContents="skip"/>
            </xs:sequence>
            <xs:attribute name="flag" type="NonEmptyString" use="optional"/>
            <xs:attribute name="see" type="NonEmptyString" use="optional"/>
            <xs:attribute name="role" type="AssertRole" use="required"/>
            <xs:attribute name="test" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="defineVariable">
        <xs:complexType mixed="true">
            <xs:sequence>
                <xs:element name="code" minOccurs="0" maxOccurs="1" type="VarCode"/>
                <xs:element name="use" minOccurs="0" maxOccurs="1" type="VarUse"/>
            </xs:sequence>
            <xs:attribute name="name" type="xs:NCName" use="required"/>
            <xs:attribute name="path" type="xs:anyURI" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:complexType name="VarCode">
        <xs:attribute name="code" use="required" type="EnumerationString"/>
        <xs:attribute name="codeSystem" use="required" type="OidOrNullFlavor"/>
    </xs:complexType>
    <xs:complexType name="VarUse">
        <xs:attribute name="path" use="required" type="xs:anyURI"/>
        <xs:attribute name="as" use="required" type="DatatypeName"/>
    </xs:complexType>
    <xs:simpleType name="AssertRole">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="fatal"/>
            <xs:enumeration value="error"/>
            <xs:enumeration value="warning"/>
            <xs:enumeration value="hint"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="item">
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
            </xs:sequence>
            <xs:attribute name="label" type="NonEmptyString" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="context">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Template/context</sch:title>
                    <sch:rule context="template/context">
                        <sch:assert test="not(@id and @path)">ERROR: template/context SHALL have @id or @path, not both</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <!-- Was: SelfReferenceTemplateIdOrOid, but the Oid construct never made it into the template DSTU and is not currently in use or supported by DECOR2Schematron -->
            <xs:attribute name="id" use="optional" type="SelfReferenceTemplateId"/>
            <xs:attribute name="path" use="optional" type="xs:anyURI"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="SelfReferenceTemplateId">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used as the type of a context template id</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="*">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">template scope is templateId element and sibling nodes. Requires a top level element templateId with the same id as the template itself</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="**">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">template scope is top level element with templateId element and child nodes. Requires that the template has one top level element and an element templateId with the same id as the template itself as child of that top level element</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="SelfReferenceTemplateIdOrOid">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">a string "*" or "**" or a valid Oid. The value * requires a top level element templateId with the same id as the template itself. The value ** requires that the template has one top level element and an element templateId with the same id as the template itself as child of that top level element. When context/@id contains an Oid, the template requires requires a top level element templateId with that same id</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="SelfReferenceTemplateId Oid"/>
    </xs:simpleType>
    <xs:element name="pathname">
        <xs:complexType>
            <xs:attribute name="path" use="required" type="Uri"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="DecimalRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">A real number that is restricted to a maximum of 10 characters, and may have no more than 5 decimal places.</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:decimal">
            <xs:maxExclusive value="1000000000"/>
            <xs:minInclusive value="-1000000000"/>
            <xs:fractionDigits value="5"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IntegerRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">An integer number that is restricted to a maximum of 10 characters</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:integer">
            <xs:maxExclusive value="1000000000"/>
            <xs:minInclusive value="-1000000000"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="IntegerOrDecimalRange">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">An integer or decimal range</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="IntegerRange DecimalRange"/>
    </xs:simpleType>
    <xs:element name="cardinality">
        <xs:complexType>
            <xs:annotation>
                <xs:appinfo>
                    <!--
                    <sch:pattern>
                        <sch:title>Validate Cardinality</sch:title>
                        <sch:rule context="cardinality">
                            <sch:extends rule="MultiplicityRange"/>
                        </sch:rule>
                    </sch:pattern>
                    -->
                </xs:appinfo>
            </xs:annotation>
            <xs:attributeGroup ref="MultiplicityRangeRequired"/>
            <xs:attribute name="conformance" type="ConformanceType"/>
            <xs:attribute name="isMandatory" type="xs:boolean" default="false"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="attribute">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Attribute</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/attribute">
                        <!--sch:assert role="warning" test="not(@datatype)"
                            >WARNING: The datatype SHOULD be specified on "element". Specification on "attribute" has been deprecated</sch:assert-->
                        <!--sch:assert role="error" test="@datatype = parent::element/@datatype or not(@datatype) or not(parent::element/@datatype)"
                            >ERROR: The datatype on "attribute" SHALL be equal to the datatype on "element"</sch:assert-->
                        <!--sch:assert role="warning" test="not(vocabulary)"
                            >WARNING: The vocabalary elements SHOULD be immediate children of "element". Specification as children of "attribute" has been deprecated</sch:assert-->
                        <!--<sch:assert role="error" test="not(@name or @value) or (@name and (@value or vocabulary))"
                            >ERROR: attribute MUST have both @name and (@value or vocabulary), or neither.</sch:assert>
                            -->
                        <!--
                        <sch:assert role="warning" test="not(@unit or @name='unit')">WARNING: attribute specifies @unit. This attribute SHOULD be specified through <property
                            unit="..."/></sch:assert>
                        -->
                        <sch:assert role="error" test="not(@name='xsi:type' and @value) or (@name='xsi:type' and @value=parent::element/@datatype)"
                            >ERROR: attribute @xsi:type SHOULD NOT specify a value, or SHOULD specify a value that matches the element definition.</sch:assert>
                        <sch:assert role="error" test="not((@extension|@operator|@contextControlCode|@institutionSpecified|@independentInd|@determinerCode|@contextConductionInd|@inversionInd|@negationInd)[contains(.,'|')])"
                            >ERROR: this attribute cannot define a choice for its value. Please use @name.</sch:assert>
                        
                        <!-- Background: the check on valueSet does not consider code(System)s in the other vocabulary element and vice versa. So there will be errors about a valid codeSystem or a valid code regardless -->
                        <!--<sch:assert role="warning" test="not(vocabulary[@valueSet] and vocabulary[@code or @codeSystem])"
                            >WARNING: combining vocabulary definitions based on a valueSet and based on a @code and/or @codeSystem is currently not supported in the schematron engine. Consider creating a valueSet that supports the specified combination.</sch:assert>-->
                        
                        <sch:let name="datatypeFile" value="'DECOR-supported-datatypes.xml'"/>
                        <!--<sch:let name="dtNsURI" value="if (contains(@datatype,':')) then namespace-uri-for-prefix(substring-before(@datatype,':')) else ('urn:hl7-org:v3')"/>-->
                        <sch:let name="dtName" value="if (contains(@datatype,':')) then substring-after(@datatype,':') else (@datatype)"/>
                        <sch:assert role="error" test="not(doc-available($datatypeFile)) or not(@datatype) or $dtName=doc($datatypeFile)//atomicDataType//@name"
                            >ERROR: the attribute/@datatype '<sch:value-of select="@datatype"/>' SHALL be a supported datatype</sch:assert>
                        
                        <sch:assert role="error" test="not(contains(@value,'|'))"
                            >ERROR: the attribute/@name='<sch:value-of select="@name"/>' SHOULD NOT have a choice as its @value ('<sch:value-of select="@value"/>'). The schematron engine will NOT support that and treat it as a literal string.</sch:assert>
                        
                        <sch:assert role="error" test="true()=(
                                for $att in (@name , @*[name()=('classCode','moodCode','extension','root','typeCode','contextControlCode','operator','institutionSpecified', 'unit','determinerCode','contextConductionInd','inversionInd','independentInd','negationInd','mediaType','representation','use','qualifier','nullFlavor')]/name()) 
                                return count(../attribute[@name=$att or @*[not(name()=('name','value','isOptional','prohibited','datatype'))]/name()=$att])=1)"
                            >ERROR: an attribute SHALL NOT be defined more than once on the same element</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="desc" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                <!-- item label, inherited by all subsequent elements unless overridden -->
                <xs:element ref="item" minOccurs="0" maxOccurs="1"/>
                
                <xs:choice>
                    <xs:element ref="vocabulary" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="constraint" minOccurs="0" maxOccurs="unbounded" type="FreeFormMarkupWithLanguage"/>
                </xs:choice>
                
                <!-- constraints for attributes of type "coded" or "quantities"??????? -->
                <!-- 
                    <xs:choice maxOccurs="1">
                    <xs:element ref="vocabulary" minOccurs="0" maxOccurs="1"/>
                    <xs:element ref="property" minOccurs="0" maxOccurs="1"/>
                </xs:choice>
                -->
            </xs:sequence>

            <!-- real attributes -->
            <xs:attribute name="classCode" type="EnumerationString"/>
            <xs:attribute name="moodCode" type="EnumerationString"/>
            <xs:attribute name="extension" type="EnumerationString"/>
            <xs:attribute name="root" type="OidChoiceList"/>
            <xs:attribute name="typeCode" type="EnumerationString"/>
            <xs:attribute name="contextControlCode" type="EnumerationToken"/>
            <xs:attribute name="operator" type="EnumerationToken"/>
            <xs:attribute name="institutionSpecified" type="xs:boolean"/>
            <xs:attribute name="unit" type="NonEmptyString"/>
            <xs:attribute name="determinerCode" type="EnumerationToken"/>
            <xs:attribute name="contextConductionInd" type="xs:boolean"/>
            <xs:attribute name="inversionInd" type="xs:boolean"/>
            <xs:attribute name="independentInd" type="xs:boolean"/>
            <xs:attribute name="negationInd" type="EnumerationString"/>
            <xs:attribute name="mediaType" type="EnumerationString"/>
            <xs:attribute name="representation" type="EnumerationString"/>
            <xs:attribute name="use" type="EnumerationString"/>
            <xs:attribute name="qualifier" type="EnumerationString"/>
            <!-- null flavor constraints -->
            <xs:attribute name="nullFlavor" type="EnumerationString"/>
            
            <!-- attribute optionality -->
            <xs:attribute name="isOptional" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines that the attribute is requird to be in the instance. Default is 'false', meaning that the attribute is NOT optional, and thus required.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <!-- attribute prohibited -->
            <xs:attribute name="prohibited" type="xs:boolean">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">Determines that the attribute is prohibited to be in the instance.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            
            <!-- name of attributes required (name) -->
            <xs:attribute name="name" type="EnumerationToken"/>
            
            <!-- data type II: elements where other siblings are allowed -->
            <xs:attribute name="value" type="NonEmptyString"/>

            <!-- data types for attributes only -->
            <!--<xs:attribute name="datatype" type="AttributeDatatypeName"/>-->
            <xs:attribute name="datatype" type="xs:QName"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="AttributeDatatypeName">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Used for datatype names of attributes only</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:maxLength value="60"/>
            <xs:pattern value="[a-z_]+(.[a-z]+)*(.diffType)?"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="property">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                        <sch:title>Validate Property</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/property">
                        <sch:assert role="error" test="count(@* except (@unit|@minInclude|@maxInclude|@fractionDigits))=0 or count(@* except (@currency|@minInclude|@maxInclude|@fractionDigits))=0 or count(@* except (@minLength|@maxLength))=0 or count(@* except (@value))=0">ERROR: property contains illegal combination of attributes.</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Used for attributes of type "quantity", "string" or "boolean". Allows assertion of one or more units, ranges, fraction digits or fixed values. Valid
                combinations of attributes are: <li>
                    <ul>@unit @minInclude @maxInclude @fractionDigits</ul>
                    <ul>@currency @minInclude @maxInclude @fractionDigits</ul>
                    <ul>@minLength @maxLength</ul>
                    <ul>@value</ul>
                </li>
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>

            <!-- quantity constraints -->
            <xs:attribute name="unit" type="NonEmptyString"/>
            <xs:attribute name="currency" type="NonEmptyString"/>
            <xs:attribute name="minInclude" type="IntegerOrDecimalRange"/>
            <xs:attribute name="maxInclude" type="IntegerOrDecimalRange"/>
            <xs:attribute name="fractionDigits" type="FractionDigitsType"/>

            <!-- string constraints -->
            <xs:attribute name="minLength" type="SmallNonNegativeInteger"/>
            <xs:attribute name="maxLength" type="SmallNonNegativeInteger"/>

            <!-- fixed values -->
            <xs:attribute name="value" type="NonEmptyString"/>
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="FractionDigitsType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Data Set Value Domain Time Stamp Precision</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:pattern value="\d{1,4}[!]{0,1}"/>
        </xs:restriction>
    </xs:simpleType>
    <xs:element name="vocabulary">
        <xs:annotation>
            <xs:appinfo>
                <sch:pattern>
                    <sch:title>Validate Attribute Vocabulary</sch:title>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//attribute/vocabulary">
                        <sch:assert role="error" test="count(@* except (@valueSet|@flexibility|@code|@strength))=0"
                            >ERROR: <sch:name path=".."/>/<sch:name/> SHALL NOT have other attributes than @valueSet, @flexibility, @strength or @code.</sch:assert>
                        <sch:assert test="not(@valueSet) or count(@* except (@valueSet|@flexibility|@strength))=0"
                            >ERROR: <sch:name path=".."/>/<sch:name/>/@valueSet SHALL NOT co-occur with any other attribute than @flexibility or @strength</sch:assert>
                        <sch:assert test="not(@domain) or count(@* except (@domain))=0"
                            >ERROR: <sch:name/>/@domain SHALL NOT co-occur with any other attribute</sch:assert>
                        
                        <sch:assert test="not(@valueSet) or @valueSet=//terminology/valueSet/(@ref|@id|@name)"
                            >ERROR: <sch:name/>/@valueSet="<sch:value-of select="@valueSet"/>" SHALL have a matching terminology/valueSet</sch:assert>
                        <sch:assert test="not(@strength) or (@valueSet|@codeSystem)"
                            >ERROR: <sch:name/>/@strength SHALL only be used in conjunction with @valueSet or @codeSystem</sch:assert>
                    </sch:rule>
                    <sch:rule context="template[not(@statusCode=('cancelled','rejected','retired'))]//element/vocabulary">
                        <sch:assert test="not(@valueSet) or count(@* except (@valueSet|@flexibility|@strength))=0"
                            >ERROR: <sch:name/>/@valueSet SHALL NOT co-occur with any other attribute than @flexibility or @strength</sch:assert>
                        <sch:assert test="not(@domain) or count(@* except (@domain))=0"
                            >ERROR: <sch:name/>/@domain SHALL NOT co-occur with any other attribute</sch:assert>
                        
                        <sch:let name="vsref" value="@valueSet"/>
                        <sch:let name="vsflex" value="if (matches(@flexibility,'^\d{4}')) then @flexibility else (string(max(//terminology/valueSet[(@name|@id|@ref)=$vsref][@effectiveDate]/xs:dateTime(@effectiveDate))))"/>
                        <sch:let name="vsflextext" value="if (matches(@flexibility,'^\d{4}')) then @flexibility else ('dynamic')"/>
                        <sch:let name="vs" value="//terminology/valueSet[(@name|@id|@ref)=$vsref][not(@effectiveDate) or @effectiveDate=$vsflex]"/>
                        
                        <sch:assert test="not(@valueSet) or @valueSet=//terminology/valueSet/(@ref|@id|@name)"
                            >ERROR: <sch:name/>/@valueSet="<sch:value-of select="@valueSet"/>" SHALL have a matching terminology/valueSet</sch:assert>
                        <sch:assert role="warning" test=" not(@valueSet) or not($vs[@id]/conceptList/(exception|insert[@exception='true']) and parent::element[@isMandatory='true'])"
                            >WARNING: <sch:name/>/@valueSet '<sch:value-of select="$vsref"/>' (<sch:value-of select="$vsflextext"/>) contains exceptions, but element has @isMandatory='true'. This renders those exceptions invalid in this context.</sch:assert>
                        <!-- cannot check valueSet/@ref so make exception for that situation... -->
                        <sch:assert role="warning" test="not(@valueSet) or $vs[@id]/conceptList/(exception|insert[@exception='true']) or parent::element[@isMandatory='true'] or not(parent::element[number(@minimumMultiplicity)>0][@conformance='R']) or $vs[@ref]"
                            >WARNING: <sch:name/>/@valueSet '<sch:value-of select="$vsref"/>' (<sch:value-of select="$vsflextext"/>) does not contain exceptions, but element has @conformance 'required' and @minimumMultiplicity > 0. This effectively places all nullFlavors in scope, making it harder to implement</sch:assert>
                        <sch:assert test="not(@strength) or (@valueSet|@codeSystem)"
                            >ERROR: <sch:name/>/@strength SHALL only be used in conjunction with @valueSet or @codeSystem</sch:assert>
                    </sch:rule>
                </sch:pattern>
            </xs:appinfo>
            <xs:documentation xml:lang="en-US">Used for attributes of "coded" types. Allows assertion of one or more codes, code systems or value sets.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <!-- value set assertions -->
            <xs:attribute name="valueSet" type="BasicIdOrOid"/>
            <!-- 2DO: or OID of a value set -->
            <xs:attribute name="flexibility" type="StaticOrDynamicFlexibility"/>

            <!-- code constraints -->
            <xs:attribute name="code" type="EnumerationString"/>
            <xs:attribute name="codeSystem" type="Oid"/>

            <!-- other constraints -->
            <xs:attribute ref="displayName"/>
            <xs:attribute name="codeSystemName" type="NonEmptyString"/>
            
            <!-- concept domain (a sinple string as an "abstract" indication only) -->
            <xs:attribute name="domain" type="NonEmptyString"/>
            
            <!-- coding strength -->
            <xs:attribute name="strength" type="CodingStrengthType" default="CNE"/>
            
        </xs:complexType>
    </xs:element>
    <xs:simpleType name="CodingStrengthType">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Coding strength of a vocabulary binding</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="CNE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Gecodeerd zonder uitzonderingen</xforms:label>
                        <xforms:label xml:lang="en-US">Coded with no Exceptions</xforms:label>
                        <xforms:label xml:lang="de-DE">Coded with no Exceptions</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="CWE">
                <xs:annotation>
                    <xs:appinfo>
                        <xforms:label xml:lang="nl-NL">Gecodeerd met uitzonderingen</xforms:label>
                        <xforms:label xml:lang="en-US">Coded with Exceptions</xforms:label>
                        <xforms:label xml:lang="de-DE">Coded with Exceptions</xforms:label>
                    </xs:appinfo>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="StaticFlexibility">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">As an expression of static flexibility this contains simply a valid date (without the prefix "static")</xs:documentation>
        </xs:annotation>
        <xs:restriction base="TimeStampNoTimezone"/>
    </xs:simpleType>
    <xs:simpleType name="DynamicFlexibility">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Fixed string "dynamic", means most recent version of the object</xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="dynamic">
                <xs:annotation>
                    <xs:documentation xml:lang="en-US">dynamic</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>
    <xs:simpleType name="StaticOrDynamicFlexibility">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Either the fixed string "dynamic" or a valid xs:date as an effective date of the version of the object</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="DynamicFlexibility StaticFlexibility"/>
    </xs:simpleType>
    <xs:simpleType name="BasicIdOrOid">
        <xs:annotation>
            <xs:documentation xml:lang="en-US">Either a string or an oid in order to identify the object</xs:documentation>
        </xs:annotation>
        <xs:union memberTypes="BasicId Oid"/>
    </xs:simpleType>



    <!-- =================================== -->
</xs:schema>